{"version":3,"file":"epicenter.js","sources":["webpack://epicenter/webpack/universalModuleDefinition","webpack://epicenter/webpack/bootstrap","webpack://epicenter/./node_modules/@babel/runtime/helpers/arrayLikeToArray.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/assertThisInitialized.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/asyncToGenerator.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/construct.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/createClass.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/defineProperty.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/get.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/getPrototypeOf.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/inherits.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/isNativeFunction.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/iterableToArray.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/nonIterableSpread.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/objectWithoutProperties.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/setPrototypeOf.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/slicedToArray.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/superPropBase.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/toConsumableArray.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/typeof.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","webpack://epicenter/./node_modules/@babel/runtime/helpers/wrapNativeSuper.js","webpack://epicenter/./node_modules/@babel/runtime/regenerator/index.js","webpack://epicenter/./node_modules/cometd/AckExtension.js","webpack://epicenter/./node_modules/cometd/ReloadExtension.js","webpack://epicenter/./node_modules/cometd/cometd.js","webpack://epicenter/./node_modules/cross-fetch/dist/browser-ponyfill.js","webpack://epicenter/./node_modules/regenerator-runtime/runtime.js","webpack://epicenter/./src/adapters/account.js","webpack://epicenter/./src/adapters/authentication.js","webpack://epicenter/./src/adapters/channel.js","webpack://epicenter/./src/adapters/cometd.js","webpack://epicenter/./src/adapters/episode.js","webpack://epicenter/./src/adapters/group.js","webpack://epicenter/./src/adapters/index.js","webpack://epicenter/./src/adapters/presence.js","webpack://epicenter/./src/adapters/project.js","webpack://epicenter/./src/adapters/run.js","webpack://epicenter/./src/adapters/vault.js","webpack://epicenter/./src/adapters/world.js","webpack://epicenter/./src/epicenter.js","webpack://epicenter/./src/utils/config.js","webpack://epicenter/./src/utils/constants.js","webpack://epicenter/./src/utils/cookies.js","webpack://epicenter/./src/utils/error-manager.js","webpack://epicenter/./src/utils/error.js","webpack://epicenter/./src/utils/fault.js","webpack://epicenter/./src/utils/helpers.js","webpack://epicenter/./src/utils/identification.js","webpack://epicenter/./src/utils/index.js","webpack://epicenter/./src/utils/result.js","webpack://epicenter/./src/utils/router.js","webpack://epicenter/./src/utils/store.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"epicenter\"] = factory();\n\telse\n\t\troot[\"epicenter\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nmodule.exports = _arrayWithoutHoles;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nvar isNativeReflectConstruct = require(\"./isNativeReflectConstruct\");\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","var superPropBase = require(\"./superPropBase\");\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    module.exports = _get = Reflect.get;\n  } else {\n    module.exports = _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nmodule.exports = _get;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nmodule.exports = _isNativeFunction;","function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nmodule.exports = _isNativeReflectConstruct;","function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableSpread;","var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;","function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nmodule.exports = _superPropBase;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nvar setPrototypeOf = require(\"./setPrototypeOf\");\n\nvar isNativeFunction = require(\"./isNativeFunction\");\n\nvar construct = require(\"./construct\");\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nmodule.exports = _wrapNativeSuper;","module.exports = require(\"regenerator-runtime\");\n","/*\n * Copyright (c) 2008-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n(function(root, factory){\n    if (typeof exports === 'object') {\n        module.exports = factory(require('./cometd'));\n    } else if (typeof define === 'function' && define.amd) {\n        define(['./cometd'], factory);\n    } else {\n        factory(root.org.cometd);\n    }\n}(this, function(cometdModule) {\n    /**\n     * This client-side extension enables the client to acknowledge to the server\n     * the messages that the client has received.\n     * For the acknowledgement to work, the server must be configured with the\n     * correspondent server-side ack extension. If both client and server support\n     * the ack extension, then the ack functionality will take place automatically.\n     * By enabling this extension, all messages arriving from the server will arrive\n     * via /meta/connect, so the comet communication will be slightly chattier.\n     * The fact that all messages will return via /meta/connect means also that the\n     * messages will arrive with total order, which is not guaranteed if messages\n     * can arrive via both /meta/connect and normal response.\n     * Messages are not acknowledged one by one, but instead a batch of messages is\n     * acknowledged when the /meta/connect returns.\n     */\n    return cometdModule.AckExtension = function() {\n        var _cometd;\n        var _serverSupportsAcks = false;\n        var _batch;\n\n        function _debug(text, args) {\n            _cometd._debug(text, args);\n        }\n\n        this.registered = function(name, cometd) {\n            _cometd = cometd;\n            _debug('AckExtension: executing registration callback');\n        };\n\n        this.unregistered = function() {\n            _debug('AckExtension: executing unregistration callback');\n            _cometd = null;\n        };\n\n        this.incoming = function(message) {\n            var channel = message.channel;\n            var ext = message.ext;\n            if (channel === '/meta/handshake') {\n                if (ext) {\n                    var ackField = ext.ack;\n                    if (typeof ackField === 'object') {\n                        // New format.\n                        _serverSupportsAcks = ackField.enabled === true;\n                        var batch = ackField.batch;\n                        if (typeof batch === 'number') {\n                            _batch = batch;\n                        }\n                    } else {\n                        // Old format.\n                        _serverSupportsAcks = ackField === true;\n                    }\n                }\n                _debug('AckExtension: server supports acknowledgements', _serverSupportsAcks);\n            } else if (channel === '/meta/connect' && message.successful && _serverSupportsAcks) {\n                if (ext && typeof ext.ack === 'number') {\n                    _batch = ext.ack;\n                    _debug('AckExtension: server sent batch', _batch);\n                }\n            }\n            return message;\n        };\n\n        this.outgoing = function(message) {\n            var channel = message.channel;\n            if (!message.ext) {\n                message.ext = {};\n            }\n            if (channel === '/meta/handshake') {\n                message.ext.ack = _cometd && _cometd.ackEnabled !== false;\n                _serverSupportsAcks = false;\n                _batch = 0;\n            } else if (channel === '/meta/connect') {\n                if (_serverSupportsAcks) {\n                    message.ext.ack = _batch;\n                    _debug('AckExtension: client sending batch', _batch);\n                }\n            }\n            return message;\n        };\n    };\n}));\n","/*\n * Copyright (c) 2008-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n(function(root, factory) {\n    if (typeof exports === 'object') {\n        module.exports = factory(require('./cometd'));\n    } else if (typeof define === 'function' && define.amd) {\n        define(['./cometd'], factory);\n    } else {\n        factory(root.org.cometd);\n    }\n}(this, function(cometdModule) {\n    /**\n     * The reload extension allows a page to be loaded (or reloaded)\n     * without having to re-handshake in the new (or reloaded) page,\n     * therefore resuming the existing CometD connection.\n     *\n     * When the reload() method is called, the state of the CometD\n     * connection is stored in the window.sessionStorage object.\n     * The reload() method must therefore be called by page unload\n     * handlers, often provided by JavaScript toolkits.\n     *\n     * When the page is (re)loaded, this extension checks the\n     * window.sessionStorage and restores the CometD connection,\n     * maintaining the same CometD clientId.\n     */\n    return cometdModule.ReloadExtension = function(configuration) {\n        var _cometd;\n        var _debug;\n        var _state = {};\n        var _name = 'org.cometd.reload';\n        var _batch = false;\n        var _reloading = false;\n\n        function _reload(config) {\n            if (_state.handshakeResponse) {\n                _reloading = true;\n                var transport = _cometd.getTransport();\n                if (transport) {\n                    transport.abort();\n                }\n                _configure(config);\n                var state = JSON.stringify(_state);\n                _debug('Reload extension saving state', state);\n                window.sessionStorage.setItem(_name, state);\n            }\n        }\n\n        function _similarState(oldState) {\n            // We want to check here that the CometD object\n            // did not change much between reloads.\n            // We just check the URL for now, but in future\n            // further checks may involve the transport type\n            // and other configuration parameters.\n            return _state.url === oldState.url;\n        }\n\n        function _configure(config) {\n            if (config) {\n                if (typeof config.name === 'string') {\n                    _name = config.name;\n                }\n            }\n        }\n\n        function _receive(response) {\n            _cometd.receive(response);\n        }\n\n        this.configure = _configure;\n\n        this._receive = _receive;\n\n        this.registered = function(name, cometd) {\n            _cometd = cometd;\n            _cometd.reload = _reload;\n            _debug = _cometd._debug;\n        };\n\n        this.unregistered = function() {\n            delete _cometd.reload;\n            _cometd = null;\n        };\n\n        this.outgoing = function(message) {\n            switch (message.channel) {\n                case '/meta/handshake':\n                {\n                    _state = {};\n                    _state.url = _cometd.getURL();\n\n                    var state = window.sessionStorage.getItem(_name);\n                    _debug('Reload extension found state', state);\n                    // Is there a saved handshake response from a prior load ?\n                    if (state) {\n                        try {\n                            var oldState = JSON.parse(state);\n\n                            // Remove the state, not needed anymore\n                            window.sessionStorage.removeItem(_name);\n\n                            if (oldState.handshakeResponse && _similarState(oldState)) {\n                                _debug('Reload extension restoring state', oldState);\n\n                                // Since we are going to abort this message,\n                                // we must save an eventual callback to restore\n                                // it when we replay the handshake response.\n                                var callback = _cometd._getCallback(message.id);\n\n                                var self = this;\n                                setTimeout(function() {\n                                    _debug('Reload extension replaying handshake response', oldState.handshakeResponse);\n                                    _state.handshakeResponse = oldState.handshakeResponse;\n                                    _state.transportType = oldState.transportType;\n\n                                    // Restore the callback.\n                                    _cometd._putCallback(message.id, callback);\n\n                                    var response = _cometd._mixin(true, {}, _state.handshakeResponse, {\n                                        // Keep the response message id the same as the request.\n                                        id: message.id,\n                                        // Tells applications this is a handshake replayed by the reload extension.\n                                        ext: {\n                                            reload: true\n                                        }\n                                    });\n                                    // Use the same transport as before.\n                                    response.supportedConnectionTypes = [_state.transportType];\n\n                                    self._receive(response);\n                                    _debug('Reload extension replayed handshake response', response);\n                                }, 0);\n\n                                // Delay any sends until first connect is complete.\n                                // This avoids that there is an old /meta/connect pending on server\n                                // that will be resumed to send messages to the client, when the\n                                // client has already closed the connection, thereby losing the messages.\n                                if (!_batch) {\n                                    _batch = true;\n                                    _cometd.startBatch();\n                                }\n\n                                // This handshake is aborted, as we will replay the prior handshake response\n                                return null;\n                            } else {\n                                _debug('Reload extension could not restore state', oldState);\n                            }\n                        } catch (x) {\n                            _debug('Reload extension error while trying to restore state', x);\n                        }\n                    }\n                    break;\n                }\n                case '/meta/connect':\n                {\n                    if (_reloading === true) {\n                        // The reload causes the failure of the outstanding /meta/connect,\n                        // which CometD will react to by sending another. Here we avoid\n                        // that /meta/connect messages are sent between the reload and\n                        // the destruction of the JavaScript context, so that we are sure\n                        // that the first /meta/connect is the one triggered after the\n                        // replay of the /meta/handshake by this extension.\n                        _debug('Reload extension aborting /meta/connect during reload');\n                        return null;\n                    }\n\n                    if (!_state.transportType) {\n                        _state.transportType = message.connectionType;\n                        _debug('Reload extension tracked transport type', _state.transportType);\n                    }\n                    break;\n                }\n                case '/meta/disconnect':\n                {\n                    _state = {};\n                    break;\n                }\n                default:\n                {\n                    break;\n                }\n            }\n            return message;\n        };\n\n        this.incoming = function(message) {\n            if (message.successful) {\n                switch (message.channel) {\n                    case '/meta/handshake':\n                    {\n                        // If the handshake response is already present, then we're replaying it.\n                        // Since the replay may have modified the handshake response, do not record it here.\n                        if (!_state.handshakeResponse) {\n                            // Save successful handshake response\n                            _state.handshakeResponse = message;\n                            _debug('Reload extension tracked handshake response', message);\n                        }\n                        break;\n                    }\n                    case '/meta/connect':\n                    {\n                        if (_batch) {\n                            _batch = false;\n                            _cometd.endBatch();\n                        }\n                        break;\n                    }\n                    case '/meta/disconnect':\n                    {\n                        _state = {};\n                        break;\n                    }\n                    default:\n                    {\n                        break;\n                    }\n                }\n            }\n            return message;\n        };\n\n        _configure(configuration);\n    };\n}));\n","/*\n * Copyright (c) 2008-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* CometD Version 4.0.7 */\n\n(function(root, factory) {\n    if (typeof exports === 'object') {\n        // CommonJS.\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD.\n        define([], factory);\n    } else {\n        // Globals.\n        root.org = root.org || {};\n        root.org.cometd = factory();\n    }\n}(this, function() {\n    /**\n     * Browsers may throttle the Window scheduler,\n     * so we may replace it with a Worker scheduler.\n     */\n    var Scheduler = function() {\n        var _ids = 0;\n        var _tasks = {};\n        this.register = function(funktion) {\n            var id = ++_ids;\n            _tasks[id] = funktion;\n            return id;\n        };\n        this.unregister = function(id) {\n            var funktion = _tasks[id];\n            delete _tasks[id];\n            return funktion;\n        };\n        this.setTimeout = function(funktion, delay) {\n            return window.setTimeout(funktion, delay);\n        };\n        this.clearTimeout = function(id) {\n            window.clearTimeout(id);\n        };\n    };\n\n    /**\n     * The scheduler code that will run in the Worker.\n     * Workers have a built-in `self` variable similar to `window`.\n     */\n    function WorkerScheduler() {\n        var _tasks = {};\n        self.onmessage = function(e) {\n            var cmd = e.data;\n            var id = _tasks[cmd.id];\n            switch (cmd.type) {\n                case 'setTimeout':\n                    _tasks[cmd.id] = self.setTimeout(function() {\n                        delete _tasks[cmd.id];\n                        self.postMessage({\n                            id: cmd.id\n                        });\n                    }, cmd.delay);\n                    break;\n                case 'clearTimeout':\n                    delete _tasks[cmd.id];\n                    if (id) {\n                        self.clearTimeout(id);\n                    }\n                    break;\n                default:\n                    throw 'Unknown command ' + cmd.type;\n            }\n        };\n    }\n\n\n    /**\n     * Utility functions.\n     */\n    var Utils = {\n        isString: function(value) {\n            if (value === undefined || value === null) {\n                return false;\n            }\n            return typeof value === 'string' || value instanceof String;\n        },\n        isArray: function(value) {\n            if (value === undefined || value === null) {\n                return false;\n            }\n            return value instanceof Array;\n        },\n        /**\n         * Returns whether the given element is contained into the given array.\n         * @param element the element to check presence for\n         * @param array the array to check for the element presence\n         * @return the index of the element, if present, or a negative index if the element is not present\n         */\n        inArray: function(element, array) {\n            for (var i = 0; i < array.length; ++i) {\n                if (element === array[i]) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    };\n\n\n    /**\n     * A registry for transports used by the CometD object.\n     */\n    var TransportRegistry = function() {\n        var _types = [];\n        var _transports = {};\n\n        this.getTransportTypes = function() {\n            return _types.slice(0);\n        };\n\n        this.findTransportTypes = function(version, crossDomain, url) {\n            var result = [];\n            for (var i = 0; i < _types.length; ++i) {\n                var type = _types[i];\n                if (_transports[type].accept(version, crossDomain, url) === true) {\n                    result.push(type);\n                }\n            }\n            return result;\n        };\n\n        this.negotiateTransport = function(types, version, crossDomain, url) {\n            for (var i = 0; i < _types.length; ++i) {\n                var type = _types[i];\n                for (var j = 0; j < types.length; ++j) {\n                    if (type === types[j]) {\n                        var transport = _transports[type];\n                        if (transport.accept(version, crossDomain, url) === true) {\n                            return transport;\n                        }\n                    }\n                }\n            }\n            return null;\n        };\n\n        this.add = function(type, transport, index) {\n            var existing = false;\n            for (var i = 0; i < _types.length; ++i) {\n                if (_types[i] === type) {\n                    existing = true;\n                    break;\n                }\n            }\n\n            if (!existing) {\n                if (typeof index !== 'number') {\n                    _types.push(type);\n                } else {\n                    _types.splice(index, 0, type);\n                }\n                _transports[type] = transport;\n            }\n\n            return !existing;\n        };\n\n        this.find = function(type) {\n            for (var i = 0; i < _types.length; ++i) {\n                if (_types[i] === type) {\n                    return _transports[type];\n                }\n            }\n            return null;\n        };\n\n        this.remove = function(type) {\n            for (var i = 0; i < _types.length; ++i) {\n                if (_types[i] === type) {\n                    _types.splice(i, 1);\n                    var transport = _transports[type];\n                    delete _transports[type];\n                    return transport;\n                }\n            }\n            return null;\n        };\n\n        this.clear = function() {\n            _types = [];\n            _transports = {};\n        };\n\n        this.reset = function(init) {\n            for (var i = 0; i < _types.length; ++i) {\n                _transports[_types[i]].reset(init);\n            }\n        };\n    };\n\n\n    /**\n     * Base object with the common functionality for transports.\n     */\n    var Transport = function() {\n        var _type;\n        var _cometd;\n        var _url;\n\n        /**\n         * Function invoked just after a transport has been successfully registered.\n         * @param type the type of transport (for example 'long-polling')\n         * @param cometd the cometd object this transport has been registered to\n         * @see #unregistered()\n         */\n        this.registered = function(type, cometd) {\n            _type = type;\n            _cometd = cometd;\n        };\n\n        /**\n         * Function invoked just after a transport has been successfully unregistered.\n         * @see #registered(type, cometd)\n         */\n        this.unregistered = function() {\n            _type = null;\n            _cometd = null;\n        };\n\n        this._debug = function() {\n            _cometd._debug.apply(_cometd, arguments);\n        };\n\n        this._mixin = function() {\n            return _cometd._mixin.apply(_cometd, arguments);\n        };\n\n        this.getConfiguration = function() {\n            return _cometd.getConfiguration();\n        };\n\n        this.getAdvice = function() {\n            return _cometd.getAdvice();\n        };\n\n        this.setTimeout = function(funktion, delay) {\n            return _cometd.setTimeout(funktion, delay);\n        };\n\n        this.clearTimeout = function(id) {\n            _cometd.clearTimeout(id);\n        };\n\n        /**\n         * Converts the given response into an array of bayeux messages\n         * @param response the response to convert\n         * @return an array of bayeux messages obtained by converting the response\n         */\n        this.convertToMessages = function(response) {\n            if (Utils.isString(response)) {\n                try {\n                    return JSON.parse(response);\n                } catch (x) {\n                    this._debug('Could not convert to JSON the following string', '\"' + response + '\"');\n                    throw x;\n                }\n            }\n            if (Utils.isArray(response)) {\n                return response;\n            }\n            if (response === undefined || response === null) {\n                return [];\n            }\n            if (response instanceof Object) {\n                return [response];\n            }\n            throw 'Conversion Error ' + response + ', typeof ' + (typeof response);\n        };\n\n        /**\n         * Returns whether this transport can work for the given version and cross domain communication case.\n         * @param version a string indicating the transport version\n         * @param crossDomain a boolean indicating whether the communication is cross domain\n         * @param url the URL to connect to\n         * @return true if this transport can work for the given version and cross domain communication case,\n         * false otherwise\n         */\n        this.accept = function(version, crossDomain, url) {\n            throw 'Abstract';\n        };\n\n        /**\n         * Returns the type of this transport.\n         * @see #registered(type, cometd)\n         */\n        this.getType = function() {\n            return _type;\n        };\n\n        this.getURL = function() {\n            return _url;\n        };\n\n        this.setURL = function(url) {\n            _url = url;\n        };\n\n        this.send = function(envelope, metaConnect) {\n            throw 'Abstract';\n        };\n\n        this.reset = function(init) {\n            this._debug('Transport', _type, 'reset', init ? 'initial' : 'retry');\n        };\n\n        this.abort = function() {\n            this._debug('Transport', _type, 'aborted');\n        };\n\n        this.toString = function() {\n            return this.getType();\n        };\n    };\n\n    Transport.derive = function(baseObject) {\n        function F() {\n        }\n\n        F.prototype = baseObject;\n        return new F();\n    };\n\n\n    /**\n     * Base object with the common functionality for transports based on requests.\n     * The key responsibility is to allow at most 2 outstanding requests to the server,\n     * to avoid that requests are sent behind a long poll.\n     * To achieve this, we have one reserved request for the long poll, and all other\n     * requests are serialized one after the other.\n     */\n    var RequestTransport = function() {\n        var _super = new Transport();\n        var _self = Transport.derive(_super);\n        var _requestIds = 0;\n        var _metaConnectRequest = null;\n        var _requests = [];\n        var _envelopes = [];\n\n        function _coalesceEnvelopes(envelope) {\n            while (_envelopes.length > 0) {\n                var envelopeAndRequest = _envelopes[0];\n                var newEnvelope = envelopeAndRequest[0];\n                var newRequest = envelopeAndRequest[1];\n                if (newEnvelope.url === envelope.url &&\n                    newEnvelope.sync === envelope.sync) {\n                    _envelopes.shift();\n                    envelope.messages = envelope.messages.concat(newEnvelope.messages);\n                    this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);\n                    continue;\n                }\n                break;\n            }\n        }\n\n        function _transportSend(envelope, request) {\n            this.transportSend(envelope, request);\n            request.expired = false;\n\n            if (!envelope.sync) {\n                var maxDelay = this.getConfiguration().maxNetworkDelay;\n                var delay = maxDelay;\n                if (request.metaConnect === true) {\n                    delay += this.getAdvice().timeout;\n                }\n\n                this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);\n\n                var self = this;\n                request.timeout = this.setTimeout(function() {\n                    request.expired = true;\n                    var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';\n                    var failure = {\n                        reason: errorMessage\n                    };\n                    var xhr = request.xhr;\n                    failure.httpCode = self.xhrStatus(xhr);\n                    self.abortXHR(xhr);\n                    self._debug(errorMessage);\n                    self.complete(request, false, request.metaConnect);\n                    envelope.onFailure(xhr, envelope.messages, failure);\n                }, delay);\n            }\n        }\n\n        function _queueSend(envelope) {\n            var requestId = ++_requestIds;\n            var request = {\n                id: requestId,\n                metaConnect: false,\n                envelope: envelope\n            };\n\n            // Consider the /meta/connect requests which should always be present.\n            if (_requests.length < this.getConfiguration().maxConnections - 1) {\n                _requests.push(request);\n                _transportSend.call(this, envelope, request);\n            } else {\n                this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);\n                _envelopes.push([envelope, request]);\n            }\n        }\n\n        function _metaConnectComplete(request) {\n            var requestId = request.id;\n            this._debug('Transport', this.getType(), '/meta/connect complete, request', requestId);\n            if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {\n                throw '/meta/connect request mismatch, completing request ' + requestId;\n            }\n            _metaConnectRequest = null;\n        }\n\n        function _complete(request, success) {\n            var index = Utils.inArray(request, _requests);\n            // The index can be negative if the request has been aborted\n            if (index >= 0) {\n                _requests.splice(index, 1);\n            }\n\n            if (_envelopes.length > 0) {\n                var envelopeAndRequest = _envelopes.shift();\n                var nextEnvelope = envelopeAndRequest[0];\n                var nextRequest = envelopeAndRequest[1];\n                this._debug('Transport dequeued request', nextRequest.id);\n                if (success) {\n                    if (this.getConfiguration().autoBatch) {\n                        _coalesceEnvelopes.call(this, nextEnvelope);\n                    }\n                    _queueSend.call(this, nextEnvelope);\n                    this._debug('Transport completed request', request.id, nextEnvelope);\n                } else {\n                    // Keep the semantic of calling response callbacks asynchronously after the request\n                    var self = this;\n                    this.setTimeout(function() {\n                        self.complete(nextRequest, false, nextRequest.metaConnect);\n                        var failure = {\n                            reason: 'Previous request failed'\n                        };\n                        var xhr = nextRequest.xhr;\n                        failure.httpCode = self.xhrStatus(xhr);\n                        nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);\n                    }, 0);\n                }\n            }\n        }\n\n        _self.complete = function(request, success, metaConnect) {\n            if (metaConnect) {\n                _metaConnectComplete.call(this, request);\n            } else {\n                _complete.call(this, request, success);\n            }\n        };\n\n        /**\n         * Performs the actual send depending on the transport type details.\n         * @param envelope the envelope to send\n         * @param request the request information\n         */\n        _self.transportSend = function(envelope, request) {\n            throw 'Abstract';\n        };\n\n        _self.transportSuccess = function(envelope, request, responses) {\n            if (!request.expired) {\n                this.clearTimeout(request.timeout);\n                this.complete(request, true, request.metaConnect);\n                if (responses && responses.length > 0) {\n                    envelope.onSuccess(responses);\n                } else {\n                    envelope.onFailure(request.xhr, envelope.messages, {\n                        httpCode: 204\n                    });\n                }\n            }\n        };\n\n        _self.transportFailure = function(envelope, request, failure) {\n            if (!request.expired) {\n                this.clearTimeout(request.timeout);\n                this.complete(request, false, request.metaConnect);\n                envelope.onFailure(request.xhr, envelope.messages, failure);\n            }\n        };\n\n        function _metaConnectSend(envelope) {\n            if (_metaConnectRequest !== null) {\n                throw 'Concurrent /meta/connect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';\n            }\n\n            var requestId = ++_requestIds;\n            this._debug('Transport', this.getType(), '/meta/connect send, request', requestId, 'envelope', envelope);\n            var request = {\n                id: requestId,\n                metaConnect: true,\n                envelope: envelope\n            };\n            _transportSend.call(this, envelope, request);\n            _metaConnectRequest = request;\n        }\n\n        _self.send = function(envelope, metaConnect) {\n            if (metaConnect) {\n                _metaConnectSend.call(this, envelope);\n            } else {\n                _queueSend.call(this, envelope);\n            }\n        };\n\n        _self.abort = function() {\n            _super.abort();\n            for (var i = 0; i < _requests.length; ++i) {\n                var request = _requests[i];\n                if (request) {\n                    this._debug('Aborting request', request);\n                    if (!this.abortXHR(request.xhr)) {\n                        this.transportFailure(request.envelope, request, {reason: 'abort'});\n                    }\n                }\n            }\n            var metaConnectRequest = _metaConnectRequest;\n            if (metaConnectRequest) {\n                this._debug('Aborting /meta/connect request', metaConnectRequest);\n                if (!this.abortXHR(metaConnectRequest.xhr)) {\n                    this.transportFailure(metaConnectRequest.envelope, metaConnectRequest, {reason: 'abort'});\n                }\n            }\n            this.reset(true);\n        };\n\n        _self.reset = function(init) {\n            _super.reset(init);\n            _metaConnectRequest = null;\n            _requests = [];\n            _envelopes = [];\n        };\n\n        _self.abortXHR = function(xhr) {\n            if (xhr) {\n                try {\n                    var state = xhr.readyState;\n                    xhr.abort();\n                    return state !== window.XMLHttpRequest.UNSENT;\n                } catch (x) {\n                    this._debug(x);\n                }\n            }\n            return false;\n        };\n\n        _self.xhrStatus = function(xhr) {\n            if (xhr) {\n                try {\n                    return xhr.status;\n                } catch (x) {\n                    this._debug(x);\n                }\n            }\n            return -1;\n        };\n\n        return _self;\n    };\n\n\n    var LongPollingTransport = function() {\n        var _super = new RequestTransport();\n        var _self = Transport.derive(_super);\n        // By default, support cross domain\n        var _supportsCrossDomain = true;\n\n        _self.accept = function(version, crossDomain, url) {\n            return _supportsCrossDomain || !crossDomain;\n        };\n\n        _self.newXMLHttpRequest = function() {\n            return new window.XMLHttpRequest();\n        };\n\n        function _copyContext(xhr) {\n            try {\n                // Copy external context, to be used in other environments.\n                xhr.context = _self.context;\n            } catch (e) {\n                // May happen if XHR is wrapped by Object.seal(),\n                // Object.freeze(), or Object.preventExtensions().\n                this._debug('Could not copy transport context into XHR', e);\n            }\n        }\n\n        _self.xhrSend = function(packet) {\n            var xhr = _self.newXMLHttpRequest();\n            _copyContext(xhr);\n            xhr.withCredentials = true;\n            xhr.open('POST', packet.url, packet.sync !== true);\n            var headers = packet.headers;\n            if (headers) {\n                for (var headerName in headers) {\n                    if (headers.hasOwnProperty(headerName)) {\n                        xhr.setRequestHeader(headerName, headers[headerName]);\n                    }\n                }\n            }\n            xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');\n            xhr.onload = function() {\n                if (xhr.status === 200) {\n                    packet.onSuccess(xhr.responseText);\n                } else {\n                    packet.onError(xhr.statusText);\n                }\n            };\n            xhr.onabort = xhr.onerror = function() {\n                packet.onError(xhr.statusText);\n            };\n            xhr.send(packet.body);\n            return xhr;\n        };\n\n        _self.transportSend = function(envelope, request) {\n            this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);\n\n            var self = this;\n            try {\n                var sameStack = true;\n                request.xhr = this.xhrSend({\n                    transport: this,\n                    url: envelope.url,\n                    sync: envelope.sync,\n                    headers: this.getConfiguration().requestHeaders,\n                    body: JSON.stringify(envelope.messages),\n                    onSuccess: function(response) {\n                        self._debug('Transport', self.getType(), 'received response', response);\n                        var success = false;\n                        try {\n                            var received = self.convertToMessages(response);\n                            if (received.length === 0) {\n                                _supportsCrossDomain = false;\n                                self.transportFailure(envelope, request, {\n                                    httpCode: 204\n                                });\n                            } else {\n                                success = true;\n                                self.transportSuccess(envelope, request, received);\n                            }\n                        } catch (x) {\n                            self._debug(x);\n                            if (!success) {\n                                _supportsCrossDomain = false;\n                                var failure = {\n                                    exception: x\n                                };\n                                failure.httpCode = self.xhrStatus(request.xhr);\n                                self.transportFailure(envelope, request, failure);\n                            }\n                        }\n                    },\n                    onError: function(reason, exception) {\n                        self._debug('Transport', self.getType(), 'received error', reason, exception);\n                        _supportsCrossDomain = false;\n                        var failure = {\n                            reason: reason,\n                            exception: exception\n                        };\n                        failure.httpCode = self.xhrStatus(request.xhr);\n                        if (sameStack) {\n                            // Keep the semantic of calling response callbacks asynchronously after the request\n                            self.setTimeout(function() {\n                                self.transportFailure(envelope, request, failure);\n                            }, 0);\n                        } else {\n                            self.transportFailure(envelope, request, failure);\n                        }\n                    }\n                });\n                sameStack = false;\n            } catch (x) {\n                _supportsCrossDomain = false;\n                // Keep the semantic of calling response callbacks asynchronously after the request\n                this.setTimeout(function() {\n                    self.transportFailure(envelope, request, {\n                        exception: x\n                    });\n                }, 0);\n            }\n        };\n\n        _self.reset = function(init) {\n            _super.reset(init);\n            _supportsCrossDomain = true;\n        };\n\n        return _self;\n    };\n\n\n    var CallbackPollingTransport = function() {\n        var _super = new RequestTransport();\n        var _self = Transport.derive(_super);\n        var jsonp = 0;\n\n        _self.accept = function(version, crossDomain, url) {\n            return true;\n        };\n\n        _self.jsonpSend = function(packet) {\n            var head = document.getElementsByTagName('head')[0];\n            var script = document.createElement('script');\n\n            var callbackName = '_cometd_jsonp_' + jsonp++;\n            window[callbackName] = function(responseText) {\n                head.removeChild(script);\n                delete window[callbackName];\n                packet.onSuccess(responseText);\n            };\n\n            var url = packet.url;\n            url += url.indexOf('?') < 0 ? '?' : '&';\n            url += 'jsonp=' + callbackName;\n            url += '&message=' + encodeURIComponent(packet.body);\n            script.src = url;\n            script.async = packet.sync !== true;\n            script.type = 'application/javascript';\n            script.onerror = function(e) {\n                packet.onError('jsonp ' + e.type);\n            };\n            head.appendChild(script);\n        };\n\n        function _failTransportFn(envelope, request, x) {\n            var self = this;\n            return function() {\n                self.transportFailure(envelope, request, 'error', x);\n            };\n        }\n\n        _self.transportSend = function(envelope, request) {\n            var self = this;\n\n            // Microsoft Internet Explorer has a 2083 URL max length\n            // We must ensure that we stay within that length\n            var start = 0;\n            var length = envelope.messages.length;\n            var lengths = [];\n            while (length > 0) {\n                // Encode the messages because all brackets, quotes, commas, colons, etc\n                // present in the JSON will be URL encoded, taking many more characters\n                var json = JSON.stringify(envelope.messages.slice(start, start + length));\n                var urlLength = envelope.url.length + encodeURI(json).length;\n\n                var maxLength = this.getConfiguration().maxURILength;\n                if (urlLength > maxLength) {\n                    if (length === 1) {\n                        var x = 'Bayeux message too big (' + urlLength + ' bytes, max is ' + maxLength + ') ' +\n                            'for transport ' + this.getType();\n                        // Keep the semantic of calling response callbacks asynchronously after the request\n                        this.setTimeout(_failTransportFn.call(this, envelope, request, x), 0);\n                        return;\n                    }\n\n                    --length;\n                    continue;\n                }\n\n                lengths.push(length);\n                start += length;\n                length = envelope.messages.length - start;\n            }\n\n            // Here we are sure that the messages can be sent within the URL limit\n\n            var envelopeToSend = envelope;\n            if (lengths.length > 1) {\n                var begin = 0;\n                var end = lengths[0];\n                this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));\n                envelopeToSend = this._mixin(false, {}, envelope);\n                envelopeToSend.messages = envelope.messages.slice(begin, end);\n                envelopeToSend.onSuccess = envelope.onSuccess;\n                envelopeToSend.onFailure = envelope.onFailure;\n\n                for (var i = 1; i < lengths.length; ++i) {\n                    var nextEnvelope = this._mixin(false, {}, envelope);\n                    begin = end;\n                    end += lengths[i];\n                    nextEnvelope.messages = envelope.messages.slice(begin, end);\n                    nextEnvelope.onSuccess = envelope.onSuccess;\n                    nextEnvelope.onFailure = envelope.onFailure;\n                    this.send(nextEnvelope, request.metaConnect);\n                }\n            }\n\n            this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);\n\n            try {\n                var sameStack = true;\n                this.jsonpSend({\n                    transport: this,\n                    url: envelopeToSend.url,\n                    sync: envelopeToSend.sync,\n                    headers: this.getConfiguration().requestHeaders,\n                    body: JSON.stringify(envelopeToSend.messages),\n                    onSuccess: function(responses) {\n                        var success = false;\n                        try {\n                            var received = self.convertToMessages(responses);\n                            if (received.length === 0) {\n                                self.transportFailure(envelopeToSend, request, {\n                                    httpCode: 204\n                                });\n                            } else {\n                                success = true;\n                                self.transportSuccess(envelopeToSend, request, received);\n                            }\n                        } catch (x) {\n                            self._debug(x);\n                            if (!success) {\n                                self.transportFailure(envelopeToSend, request, {\n                                    exception: x\n                                });\n                            }\n                        }\n                    },\n                    onError: function(reason, exception) {\n                        var failure = {\n                            reason: reason,\n                            exception: exception\n                        };\n                        if (sameStack) {\n                            // Keep the semantic of calling response callbacks asynchronously after the request\n                            self.setTimeout(function() {\n                                self.transportFailure(envelopeToSend, request, failure);\n                            }, 0);\n                        } else {\n                            self.transportFailure(envelopeToSend, request, failure);\n                        }\n                    }\n                });\n                sameStack = false;\n            } catch (xx) {\n                // Keep the semantic of calling response callbacks asynchronously after the request\n                this.setTimeout(function() {\n                    self.transportFailure(envelopeToSend, request, {\n                        exception: xx\n                    });\n                }, 0);\n            }\n        };\n\n        return _self;\n    };\n\n\n    var WebSocketTransport = function() {\n        var _super = new Transport();\n        var _self = Transport.derive(_super);\n        var _cometd;\n        // By default WebSocket is supported\n        var _webSocketSupported = true;\n        // Whether we were able to establish a WebSocket connection\n        var _webSocketConnected = false;\n        var _stickyReconnect = true;\n        // The context contains the envelopes that have been sent\n        // and the timeouts for the messages that have been sent.\n        var _context = null;\n        var _connecting = null;\n        var _connected = false;\n        var _successCallback = null;\n\n        _self.reset = function(init) {\n            _super.reset(init);\n            _webSocketSupported = true;\n            if (init) {\n                _webSocketConnected = false;\n            }\n            _stickyReconnect = true;\n            _context = null;\n            _connecting = null;\n            _connected = false;\n        };\n\n        function _forceClose(context, event) {\n            if (context) {\n                this.webSocketClose(context, event.code, event.reason);\n                // Force immediate failure of pending messages to trigger reconnect.\n                // This is needed because the server may not reply to our close()\n                // and therefore the onclose function is never called.\n                this.onClose(context, event);\n            }\n        }\n\n        function _sameContext(context) {\n            return context === _connecting || context === _context;\n        }\n\n        function _storeEnvelope(context, envelope, metaConnect) {\n            var messageIds = [];\n            for (var i = 0; i < envelope.messages.length; ++i) {\n                var message = envelope.messages[i];\n                if (message.id) {\n                    messageIds.push(message.id);\n                }\n            }\n            context.envelopes[messageIds.join(',')] = [envelope, metaConnect];\n            this._debug('Transport', this.getType(), 'stored envelope, envelopes', context.envelopes);\n        }\n\n        function _websocketConnect(context) {\n            // We may have multiple attempts to open a WebSocket\n            // connection, for example a /meta/connect request that\n            // may take time, along with a user-triggered publish.\n            // Early return if we are already connecting.\n            if (_connecting) {\n                return;\n            }\n\n            // Mangle the URL, changing the scheme from 'http' to 'ws'.\n            var url = _cometd.getURL().replace(/^http/, 'ws');\n            this._debug('Transport', this.getType(), 'connecting to URL', url);\n\n            try {\n                var protocol = _cometd.getConfiguration().protocol;\n                context.webSocket = protocol ? new window.WebSocket(url, protocol) : new window.WebSocket(url);\n                _connecting = context;\n            } catch (x) {\n                _webSocketSupported = false;\n                this._debug('Exception while creating WebSocket object', x);\n                throw x;\n            }\n\n            // By default use sticky reconnects.\n            _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;\n\n            var self = this;\n            var connectTimeout = _cometd.getConfiguration().connectTimeout;\n            if (connectTimeout > 0) {\n                context.connectTimer = this.setTimeout(function() {\n                    _cometd._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');\n                    // The connection was not opened, close anyway.\n                    _forceClose.call(self, context, {code: 1000, reason: 'Connect Timeout'});\n                }, connectTimeout);\n            }\n\n            var onopen = function() {\n                _cometd._debug('WebSocket onopen', context);\n                if (context.connectTimer) {\n                    self.clearTimeout(context.connectTimer);\n                }\n\n                if (_sameContext(context)) {\n                    _connecting = null;\n                    _context = context;\n                    _webSocketConnected = true;\n                    self.onOpen(context);\n                } else {\n                    // We have a valid connection already, close this one.\n                    _cometd._warn('Closing extra WebSocket connection', this, 'active connection', _context);\n                    _forceClose.call(self, context, {code: 1000, reason: 'Extra Connection'});\n                }\n            };\n\n            // This callback is invoked when the server sends the close frame.\n            // The close frame for a connection may arrive *after* another\n            // connection has been opened, so we must make sure that actions\n            // are performed only if it's the same connection.\n            var onclose = function(event) {\n                event = event || {code: 1000};\n                _cometd._debug('WebSocket onclose', context, event, 'connecting', _connecting, 'current', _context);\n\n                if (context.connectTimer) {\n                    self.clearTimeout(context.connectTimer);\n                }\n\n                self.onClose(context, event);\n            };\n\n            var onmessage = function(wsMessage) {\n                _cometd._debug('WebSocket onmessage', wsMessage, context);\n                self.onMessage(context, wsMessage);\n            };\n\n            context.webSocket.onopen = onopen;\n            context.webSocket.onclose = onclose;\n            context.webSocket.onerror = function() {\n                // Clients should call onclose(), but if they do not we do it here for safety.\n                onclose({code: 1000, reason: 'Error'});\n            };\n            context.webSocket.onmessage = onmessage;\n\n            this._debug('Transport', this.getType(), 'configured callbacks on', context);\n        }\n\n        function _webSocketSend(context, envelope, metaConnect) {\n            var json = JSON.stringify(envelope.messages);\n            context.webSocket.send(json);\n            this._debug('Transport', this.getType(), 'sent', envelope, '/meta/connect =', metaConnect);\n\n            // Manage the timeout waiting for the response.\n            var maxDelay = this.getConfiguration().maxNetworkDelay;\n            var delay = maxDelay;\n            if (metaConnect) {\n                delay += this.getAdvice().timeout;\n                _connected = true;\n            }\n\n            var self = this;\n            var messageIds = [];\n            for (var i = 0; i < envelope.messages.length; ++i) {\n                (function() {\n                    var message = envelope.messages[i];\n                    if (message.id) {\n                        messageIds.push(message.id);\n                        context.timeouts[message.id] = self.setTimeout(function() {\n                            _cometd._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', context);\n                            _forceClose.call(self, context, {code: 1000, reason: 'Message Timeout'});\n                        }, delay);\n                    }\n                })();\n            }\n\n            this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', context.timeouts);\n        }\n\n        _self._notifySuccess = function(fn, messages) {\n            fn.call(this, messages);\n        };\n\n        _self._notifyFailure = function(fn, context, messages, failure) {\n            fn.call(this, context, messages, failure);\n        };\n\n        function _send(context, envelope, metaConnect) {\n            try {\n                if (context === null) {\n                    context = _connecting || {\n                        envelopes: {},\n                        timeouts: {}\n                    };\n                    _storeEnvelope.call(this, context, envelope, metaConnect);\n                    _websocketConnect.call(this, context);\n                } else {\n                    _storeEnvelope.call(this, context, envelope, metaConnect);\n                    _webSocketSend.call(this, context, envelope, metaConnect);\n                }\n            } catch (x) {\n                // Keep the semantic of calling response callbacks asynchronously after the request.\n                var self = this;\n                this.setTimeout(function() {\n                    _forceClose.call(self, context, {\n                        code: 1000,\n                        reason: 'Exception',\n                        exception: x\n                    });\n                }, 0);\n            }\n        }\n\n        _self.onOpen = function(context) {\n            var envelopes = context.envelopes;\n            this._debug('Transport', this.getType(), 'opened', context, 'pending messages', envelopes);\n            for (var key in envelopes) {\n                if (envelopes.hasOwnProperty(key)) {\n                    var element = envelopes[key];\n                    var envelope = element[0];\n                    var metaConnect = element[1];\n                    // Store the success callback, which is independent from the envelope,\n                    // so that it can be used to notify arrival of messages.\n                    _successCallback = envelope.onSuccess;\n                    _webSocketSend.call(this, context, envelope, metaConnect);\n                }\n            }\n        };\n\n        _self.onMessage = function(context, wsMessage) {\n            this._debug('Transport', this.getType(), 'received websocket message', wsMessage, context);\n\n            var close = false;\n            var messages = this.convertToMessages(wsMessage.data);\n            var messageIds = [];\n            for (var i = 0; i < messages.length; ++i) {\n                var message = messages[i];\n\n                // Detect if the message is a response to a request we made.\n                // If it's a meta message, for sure it's a response; otherwise it's\n                // a publish message and publish responses don't have the data field.\n                if (/^\\/meta\\//.test(message.channel) || message.data === undefined) {\n                    if (message.id) {\n                        messageIds.push(message.id);\n\n                        var timeout = context.timeouts[message.id];\n                        if (timeout) {\n                            this.clearTimeout(timeout);\n                            delete context.timeouts[message.id];\n                            this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', context.timeouts);\n                        }\n                    }\n                }\n\n                if ('/meta/connect' === message.channel) {\n                    _connected = false;\n                }\n                if ('/meta/disconnect' === message.channel && !_connected) {\n                    close = true;\n                }\n            }\n\n            // Remove the envelope corresponding to the messages.\n            var removed = false;\n            var envelopes = context.envelopes;\n            for (var j = 0; j < messageIds.length; ++j) {\n                var id = messageIds[j];\n                for (var key in envelopes) {\n                    if (envelopes.hasOwnProperty(key)) {\n                        var ids = key.split(',');\n                        var index = Utils.inArray(id, ids);\n                        if (index >= 0) {\n                            removed = true;\n                            ids.splice(index, 1);\n                            var envelope = envelopes[key][0];\n                            var metaConnect = envelopes[key][1];\n                            delete envelopes[key];\n                            if (ids.length > 0) {\n                                envelopes[ids.join(',')] = [envelope, metaConnect];\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            if (removed) {\n                this._debug('Transport', this.getType(), 'removed envelope, envelopes', envelopes);\n            }\n\n            this._notifySuccess(_successCallback, messages);\n\n            if (close) {\n                this.webSocketClose(context, 1000, 'Disconnect');\n            }\n        };\n\n        _self.onClose = function(context, event) {\n            this._debug('Transport', this.getType(), 'closed', context, event);\n\n            if (_sameContext(context)) {\n                // Remember if we were able to connect.\n                // This close event could be due to server shutdown,\n                // and if it restarts we want to try websocket again.\n                _webSocketSupported = _stickyReconnect && _webSocketConnected;\n                _connecting = null;\n                _context = null;\n            }\n\n            var timeouts = context.timeouts;\n            context.timeouts = {};\n            for (var id in timeouts) {\n                if (timeouts.hasOwnProperty(id)) {\n                    this.clearTimeout(timeouts[id]);\n                }\n            }\n\n            var envelopes = context.envelopes;\n            context.envelopes = {};\n            for (var key in envelopes) {\n                if (envelopes.hasOwnProperty(key)) {\n                    var envelope = envelopes[key][0];\n                    var metaConnect = envelopes[key][1];\n                    if (metaConnect) {\n                        _connected = false;\n                    }\n                    var failure = {\n                        websocketCode: event.code,\n                        reason: event.reason\n                    };\n                    if (event.exception) {\n                        failure.exception = event.exception;\n                    }\n                    this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);\n                }\n            }\n        };\n\n        _self.registered = function(type, cometd) {\n            _super.registered(type, cometd);\n            _cometd = cometd;\n        };\n\n        _self.accept = function(version, crossDomain, url) {\n            this._debug('Transport', this.getType(), 'accept, supported:', _webSocketSupported);\n            // Using !! to return a boolean (and not the WebSocket object).\n            return _webSocketSupported && !!window.WebSocket && _cometd.websocketEnabled !== false;\n        };\n\n        _self.send = function(envelope, metaConnect) {\n            this._debug('Transport', this.getType(), 'sending', envelope, '/meta/connect =', metaConnect);\n            _send.call(this, _context, envelope, metaConnect);\n        };\n\n        _self.webSocketClose = function(context, code, reason) {\n            try {\n                if (context.webSocket) {\n                    context.webSocket.close(code, reason);\n                }\n            } catch (x) {\n                this._debug(x);\n            }\n        };\n\n        _self.abort = function() {\n            _super.abort();\n            _forceClose.call(this, _context, {code: 1000, reason: 'Abort'});\n            this.reset(true);\n        };\n\n        return _self;\n    };\n\n\n    /**\n     * The constructor for a CometD object, identified by an optional name.\n     * The default name is the string 'default'.\n     * @param name the optional name of this cometd object\n     */\n    var CometD = function(name) {\n        var _scheduler = new Scheduler();\n        var _cometd = this;\n        var _name = name || 'default';\n        var _crossDomain = false;\n        var _transports = new TransportRegistry();\n        var _transport;\n        var _status = 'disconnected';\n        var _messageId = 0;\n        var _clientId = null;\n        var _batch = 0;\n        var _messageQueue = [];\n        var _internalBatch = false;\n        var _listenerId = 0;\n        var _listeners = {};\n        var _backoff = 0;\n        var _scheduledSend = null;\n        var _extensions = [];\n        var _advice = {};\n        var _handshakeProps;\n        var _handshakeCallback;\n        var _callbacks = {};\n        var _remoteCalls = {};\n        var _reestablish = false;\n        var _connected = false;\n        var _unconnectTime = 0;\n        var _handshakeMessages = 0;\n        var _metaConnect = null;\n        var _config = {\n            useWorkerScheduler: true,\n            protocol: null,\n            stickyReconnect: true,\n            connectTimeout: 0,\n            maxConnections: 2,\n            backoffIncrement: 1000,\n            maxBackoff: 60000,\n            logLevel: 'info',\n            maxNetworkDelay: 10000,\n            requestHeaders: {},\n            appendMessageTypeToURL: true,\n            autoBatch: false,\n            urls: {},\n            maxURILength: 2000,\n            advice: {\n                timeout: 60000,\n                interval: 0,\n                reconnect: undefined,\n                maxInterval: 0\n            }\n        };\n\n        function _fieldValue(object, name) {\n            try {\n                return object[name];\n            } catch (x) {\n                return undefined;\n            }\n        }\n\n        /**\n         * Mixes in the given objects into the target object by copying the properties.\n         * @param deep if the copy must be deep\n         * @param target the target object\n         * @param objects the objects whose properties are copied into the target\n         */\n        this._mixin = function(deep, target, objects) {\n            var result = target || {};\n\n            // Skip first 2 parameters (deep and target), and loop over the others\n            for (var i = 2; i < arguments.length; ++i) {\n                var object = arguments[i];\n\n                if (object === undefined || object === null) {\n                    continue;\n                }\n\n                for (var propName in object) {\n                    if (object.hasOwnProperty(propName)) {\n                        var prop = _fieldValue(object, propName);\n                        var targ = _fieldValue(result, propName);\n\n                        // Avoid infinite loops\n                        if (prop === target) {\n                            continue;\n                        }\n                        // Do not mixin undefined values\n                        if (prop === undefined) {\n                            continue;\n                        }\n\n                        if (deep && typeof prop === 'object' && prop !== null) {\n                            if (prop instanceof Array) {\n                                result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);\n                            } else {\n                                var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};\n                                result[propName] = this._mixin(deep, source, prop);\n                            }\n                        } else {\n                            result[propName] = prop;\n                        }\n                    }\n                }\n            }\n\n            return result;\n        };\n\n        function _isString(value) {\n            return Utils.isString(value);\n        }\n\n        function _isFunction(value) {\n            if (value === undefined || value === null) {\n                return false;\n            }\n            return typeof value === 'function';\n        }\n\n        function _zeroPad(value, length) {\n            var result = '';\n            while (--length > 0) {\n                if (value >= Math.pow(10, length)) {\n                    break;\n                }\n                result += '0';\n            }\n            result += value;\n            return result;\n        }\n\n        function _log(level, args) {\n            if (window.console) {\n                var logger = window.console[level];\n                if (_isFunction(logger)) {\n                    var now = new Date();\n                    [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' +\n                        _zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));\n                    logger.apply(window.console, args);\n                }\n            }\n        }\n\n        this._warn = function() {\n            _log('warn', arguments);\n        };\n\n        this._info = function() {\n            if (_config.logLevel !== 'warn') {\n                _log('info', arguments);\n            }\n        };\n\n        this._debug = function() {\n            if (_config.logLevel === 'debug') {\n                _log('debug', arguments);\n            }\n        };\n\n        function _splitURL(url) {\n            // [1] = protocol://,\n            // [2] = host:port,\n            // [3] = host,\n            // [4] = IPv6_host,\n            // [5] = IPv4_host,\n            // [6] = :port,\n            // [7] = port,\n            // [8] = uri,\n            // [9] = rest (query / fragment)\n            return new RegExp('(^https?://)?(((\\\\[[^\\\\]]+])|([^:/?#]+))(:(\\\\d+))?)?([^?#]*)(.*)?').exec(url);\n        }\n\n        /**\n         * Returns whether the given hostAndPort is cross domain.\n         * The default implementation checks against window.location.host\n         * but this function can be overridden to make it work in non-browser\n         * environments.\n         *\n         * @param hostAndPort the host and port in format host:port\n         * @return whether the given hostAndPort is cross domain\n         */\n        this._isCrossDomain = function(hostAndPort) {\n            if (window.location && window.location.host) {\n                if (hostAndPort) {\n                    return hostAndPort !== window.location.host;\n                }\n            }\n            return false;\n        };\n\n        function _configure(configuration) {\n            _cometd._debug('Configuring cometd object with', configuration);\n            // Support old style param, where only the Bayeux server URL was passed.\n            if (_isString(configuration)) {\n                configuration = {\n                    url: configuration\n                };\n            }\n            if (!configuration) {\n                configuration = {};\n            }\n\n            _config = _cometd._mixin(false, _config, configuration);\n\n            var url = _cometd.getURL();\n            if (!url) {\n                throw 'Missing required configuration parameter \\'url\\' specifying the Bayeux server URL';\n            }\n\n            // Check if we're cross domain.\n            var urlParts = _splitURL(url);\n            var hostAndPort = urlParts[2];\n            var uri = urlParts[8];\n            var afterURI = urlParts[9];\n            _crossDomain = _cometd._isCrossDomain(hostAndPort);\n\n            // Check if appending extra path is supported.\n            if (_config.appendMessageTypeToURL) {\n                if (afterURI !== undefined && afterURI.length > 0) {\n                    _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n                    _config.appendMessageTypeToURL = false;\n                } else {\n                    var uriSegments = uri.split('/');\n                    var lastSegmentIndex = uriSegments.length - 1;\n                    if (uri.match(/\\/$/)) {\n                        lastSegmentIndex -= 1;\n                    }\n                    if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {\n                        // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd\n                        // It will be difficult to add the extra path in this case\n                        _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n                        _config.appendMessageTypeToURL = false;\n                    }\n                }\n            }\n\n            if (window.Worker && window.Blob && window.URL && _config.useWorkerScheduler) {\n                var code = WorkerScheduler.toString();\n                // Remove the function declaration, the opening brace and the closing brace.\n                code = code.substring(code.indexOf('{') + 1, code.lastIndexOf('}'));\n                var blob = new window.Blob([code], {\n                    type: 'application/json'\n                });\n                var blobURL = window.URL.createObjectURL(blob);\n                var worker = new window.Worker(blobURL);\n                _scheduler.setTimeout = function(funktion, delay) {\n                    var id = _scheduler.register(funktion);\n                    worker.postMessage({\n                        id: id,\n                        type: 'setTimeout',\n                        delay: delay\n                    });\n                    return id;\n                };\n                _scheduler.clearTimeout = function(id) {\n                    _scheduler.unregister(id);\n                    worker.postMessage({\n                        id: id,\n                        type: 'clearTimeout'\n                    });\n                };\n                worker.onmessage = function(e) {\n                    var id = e.data.id;\n                    var funktion = _scheduler.unregister(id);\n                    if (funktion) {\n                        funktion();\n                    }\n                };\n            }\n        }\n\n        function _removeListener(subscription) {\n            if (subscription) {\n                var subscriptions = _listeners[subscription.channel];\n                if (subscriptions && subscriptions[subscription.id]) {\n                    delete subscriptions[subscription.id];\n                    _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);\n                }\n            }\n        }\n\n        function _removeSubscription(subscription) {\n            if (subscription && !subscription.listener) {\n                _removeListener(subscription);\n            }\n        }\n\n        function _clearSubscriptions() {\n            for (var channel in _listeners) {\n                if (_listeners.hasOwnProperty(channel)) {\n                    var subscriptions = _listeners[channel];\n                    if (subscriptions) {\n                        for (var id in subscriptions) {\n                            if (subscriptions.hasOwnProperty(id)) {\n                                _removeSubscription(subscriptions[id]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        function _setStatus(newStatus) {\n            if (_status !== newStatus) {\n                _cometd._debug('Status', _status, '->', newStatus);\n                _status = newStatus;\n            }\n        }\n\n        function _isDisconnected() {\n            return _status === 'disconnecting' || _status === 'disconnected';\n        }\n\n        function _nextMessageId() {\n            var result = ++_messageId;\n            return '' + result;\n        }\n\n        function _applyExtension(scope, callback, name, message, outgoing) {\n            try {\n                return callback.call(scope, message);\n            } catch (x) {\n                var handler = _cometd.onExtensionException;\n                if (_isFunction(handler)) {\n                    _cometd._debug('Invoking extension exception handler', name, x);\n                    try {\n                        handler.call(_cometd, x, name, outgoing, message);\n                    } catch (xx) {\n                        _cometd._info('Exception during execution of extension exception handler', name, xx);\n                    }\n                } else {\n                    _cometd._info('Exception during execution of extension', name, x);\n                }\n                return message;\n            }\n        }\n\n        function _applyIncomingExtensions(message) {\n            for (var i = 0; i < _extensions.length; ++i) {\n                if (message === undefined || message === null) {\n                    break;\n                }\n\n                var extension = _extensions[i];\n                var callback = extension.extension.incoming;\n                if (_isFunction(callback)) {\n                    var result = _applyExtension(extension.extension, callback, extension.name, message, false);\n                    message = result === undefined ? message : result;\n                }\n            }\n            return message;\n        }\n\n        function _applyOutgoingExtensions(message) {\n            for (var i = _extensions.length - 1; i >= 0; --i) {\n                if (message === undefined || message === null) {\n                    break;\n                }\n\n                var extension = _extensions[i];\n                var callback = extension.extension.outgoing;\n                if (_isFunction(callback)) {\n                    var result = _applyExtension(extension.extension, callback, extension.name, message, true);\n                    message = result === undefined ? message : result;\n                }\n            }\n            return message;\n        }\n\n        function _notify(channel, message) {\n            var subscriptions = _listeners[channel];\n            if (subscriptions) {\n                for (var id in subscriptions) {\n                    if (subscriptions.hasOwnProperty(id)) {\n                        var subscription = subscriptions[id];\n                        // Subscriptions may come and go, so the array may have 'holes'\n                        if (subscription) {\n                            try {\n                                subscription.callback.call(subscription.scope, message);\n                            } catch (x) {\n                                var handler = _cometd.onListenerException;\n                                if (_isFunction(handler)) {\n                                    _cometd._debug('Invoking listener exception handler', subscription, x);\n                                    try {\n                                        handler.call(_cometd, x, subscription, subscription.listener, message);\n                                    } catch (xx) {\n                                        _cometd._info('Exception during execution of listener exception handler', subscription, xx);\n                                    }\n                                } else {\n                                    _cometd._info('Exception during execution of listener', subscription, message, x);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        function _notifyListeners(channel, message) {\n            // Notify direct listeners\n            _notify(channel, message);\n\n            // Notify the globbing listeners\n            var channelParts = channel.split('/');\n            var last = channelParts.length - 1;\n            for (var i = last; i > 0; --i) {\n                var channelPart = channelParts.slice(0, i).join('/') + '/*';\n                // We don't want to notify /foo/* if the channel is /foo/bar/baz,\n                // so we stop at the first non recursive globbing\n                if (i === last) {\n                    _notify(channelPart, message);\n                }\n                // Add the recursive globber and notify\n                channelPart += '*';\n                _notify(channelPart, message);\n            }\n        }\n\n        function _cancelDelayedSend() {\n            if (_scheduledSend !== null) {\n                _cometd.clearTimeout(_scheduledSend);\n            }\n            _scheduledSend = null;\n        }\n\n        function _delayedSend(operation, delay) {\n            _cancelDelayedSend();\n            var time = _advice.interval + delay;\n            _cometd._debug('Function scheduled in', time, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);\n            _scheduledSend = _cometd.setTimeout(operation, time);\n        }\n\n        // Needed to break cyclic dependencies between function definitions\n        var _handleMessages;\n        var _handleFailure;\n\n        /**\n         * Delivers the messages to the CometD server\n         * @param messages the array of messages to send\n         * @param metaConnect true if this send is on /meta/connect\n         * @param extraPath an extra path to append to the Bayeux server URL\n         */\n        function _send(messages, metaConnect, extraPath) {\n            // We must be sure that the messages have a clientId.\n            // This is not guaranteed since the handshake may take time to return\n            // (and hence the clientId is not known yet) and the application\n            // may create other messages.\n            for (var i = 0; i < messages.length; ++i) {\n                var message = messages[i];\n                var messageId = message.id;\n\n                if (_clientId) {\n                    message.clientId = _clientId;\n                }\n\n                message = _applyOutgoingExtensions(message);\n                if (message !== undefined && message !== null) {\n                    // Extensions may have modified the message id, but we need to own it.\n                    message.id = messageId;\n                    messages[i] = message;\n                } else {\n                    delete _callbacks[messageId];\n                    messages.splice(i--, 1);\n                }\n            }\n\n            if (messages.length === 0) {\n                return;\n            }\n\n            if (metaConnect) {\n                _metaConnect = messages[0];\n            }\n\n            var url = _cometd.getURL();\n            if (_config.appendMessageTypeToURL) {\n                // If url does not end with '/', then append it\n                if (!url.match(/\\/$/)) {\n                    url = url + '/';\n                }\n                if (extraPath) {\n                    url = url + extraPath;\n                }\n            }\n\n            var envelope = {\n                url: url,\n                sync: false,\n                messages: messages,\n                onSuccess: function(rcvdMessages) {\n                    try {\n                        _handleMessages.call(_cometd, rcvdMessages);\n                    } catch (x) {\n                        _cometd._info('Exception during handling of messages', x);\n                    }\n                },\n                onFailure: function(conduit, messages, failure) {\n                    try {\n                        var transport = _cometd.getTransport();\n                        failure.connectionType = transport ? transport.getType() : \"unknown\";\n                        _handleFailure.call(_cometd, conduit, messages, failure);\n                    } catch (x) {\n                        _cometd._info('Exception during handling of failure', x);\n                    }\n                }\n            };\n            _cometd._debug('Send', envelope);\n            _transport.send(envelope, metaConnect);\n        }\n\n        function _queueSend(message) {\n            if (_batch > 0 || _internalBatch === true) {\n                _messageQueue.push(message);\n            } else {\n                _send([message], false);\n            }\n        }\n\n        /**\n         * Sends a complete bayeux message.\n         * This method is exposed as a public so that extensions may use it\n         * to send bayeux message directly, for example in case of re-sending\n         * messages that have already been sent but that for some reason must\n         * be resent.\n         */\n        this.send = _queueSend;\n\n        function _resetBackoff() {\n            _backoff = 0;\n        }\n\n        function _increaseBackoff() {\n            if (_backoff < _config.maxBackoff) {\n                _backoff += _config.backoffIncrement;\n            }\n            return _backoff;\n        }\n\n        /**\n         * Starts a the batch of messages to be sent in a single request.\n         * @see #_endBatch(sendMessages)\n         */\n        function _startBatch() {\n            ++_batch;\n            _cometd._debug('Starting batch, depth', _batch);\n        }\n\n        function _flushBatch() {\n            var messages = _messageQueue;\n            _messageQueue = [];\n            if (messages.length > 0) {\n                _send(messages, false);\n            }\n        }\n\n        /**\n         * Ends the batch of messages to be sent in a single request,\n         * optionally sending messages present in the message queue depending\n         * on the given argument.\n         * @see #_startBatch()\n         */\n        function _endBatch() {\n            --_batch;\n            _cometd._debug('Ending batch, depth', _batch);\n            if (_batch < 0) {\n                throw 'Calls to startBatch() and endBatch() are not paired';\n            }\n\n            if (_batch === 0 && !_isDisconnected() && !_internalBatch) {\n                _flushBatch();\n            }\n        }\n\n        /**\n         * Sends the connect message\n         */\n        function _connect() {\n            if (!_isDisconnected()) {\n                var bayeuxMessage = {\n                    id: _nextMessageId(),\n                    channel: '/meta/connect',\n                    connectionType: _transport.getType()\n                };\n\n                // In case of reload or temporary loss of connection\n                // we want the next successful connect to return immediately\n                // instead of being held by the server, so that connect listeners\n                // can be notified that the connection has been re-established\n                if (!_connected) {\n                    bayeuxMessage.advice = {\n                        timeout: 0\n                    };\n                }\n\n                _setStatus('connecting');\n                _cometd._debug('Connect sent', bayeuxMessage);\n                _send([bayeuxMessage], true, 'connect');\n                _setStatus('connected');\n            }\n        }\n\n        function _delayedConnect(delay) {\n            _setStatus('connecting');\n            _delayedSend(function() {\n                _connect();\n            }, delay);\n        }\n\n        function _updateAdvice(newAdvice) {\n            if (newAdvice) {\n                _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);\n                _cometd._debug('New advice', _advice);\n            }\n        }\n\n        function _disconnect(abort) {\n            _cancelDelayedSend();\n            if (abort && _transport) {\n                _transport.abort();\n            }\n            _crossDomain = false;\n            _transport = null;\n            _setStatus('disconnected');\n            _clientId = null;\n            _batch = 0;\n            _resetBackoff();\n            _reestablish = false;\n            _connected = false;\n            _unconnectTime = 0;\n            _metaConnect = null;\n\n            // Fail any existing queued message\n            if (_messageQueue.length > 0) {\n                var messages = _messageQueue;\n                _messageQueue = [];\n                _handleFailure.call(_cometd, undefined, messages, {\n                    reason: 'Disconnected'\n                });\n            }\n        }\n\n        function _notifyTransportException(oldTransport, newTransport, failure) {\n            var handler = _cometd.onTransportException;\n            if (_isFunction(handler)) {\n                _cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);\n                try {\n                    handler.call(_cometd, failure, oldTransport, newTransport);\n                } catch (x) {\n                    _cometd._info('Exception during execution of transport exception handler', x);\n                }\n            }\n        }\n\n        /**\n         * Sends the initial handshake message\n         */\n        function _handshake(handshakeProps, handshakeCallback) {\n            if (_isFunction(handshakeProps)) {\n                handshakeCallback = handshakeProps;\n                handshakeProps = undefined;\n            }\n\n            _clientId = null;\n\n            _clearSubscriptions();\n\n            // Reset the transports if we're not retrying the handshake\n            if (_isDisconnected()) {\n                _transports.reset(true);\n            }\n\n            // Reset the advice.\n            _updateAdvice({});\n\n            _batch = 0;\n\n            // Mark the start of an internal batch.\n            // This is needed because handshake and connect are async.\n            // It may happen that the application calls init() then subscribe()\n            // and the subscribe message is sent before the connect message, if\n            // the subscribe message is not held until the connect message is sent.\n            // So here we start a batch to hold temporarily any message until\n            // the connection is fully established.\n            _internalBatch = true;\n\n            // Save the properties provided by the user, so that\n            // we can reuse them during automatic re-handshake\n            _handshakeProps = handshakeProps;\n            _handshakeCallback = handshakeCallback;\n\n            var version = '1.0';\n\n            // Figure out the transports to send to the server\n            var url = _cometd.getURL();\n            var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                version: version,\n                minimumVersion: version,\n                channel: '/meta/handshake',\n                supportedConnectionTypes: transportTypes,\n                advice: {\n                    timeout: _advice.timeout,\n                    interval: _advice.interval\n                }\n            };\n            // Do not allow the user to override important fields.\n            var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, handshakeCallback);\n\n            // Pick up the first available transport as initial transport\n            // since we don't know if the server supports it\n            if (!_transport) {\n                _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n                if (!_transport) {\n                    var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();\n                    _cometd._warn(failure);\n                    throw failure;\n                }\n            }\n\n            _cometd._debug('Initial transport is', _transport.getType());\n\n            // We started a batch to hold the application messages,\n            // so here we must bypass it and send immediately.\n            _setStatus('handshaking');\n            _cometd._debug('Handshake sent', message);\n            _send([message], false, 'handshake');\n        }\n\n        function _delayedHandshake(delay) {\n            _setStatus('handshaking');\n\n            // We will call _handshake() which will reset _clientId, but we want to avoid\n            // that between the end of this method and the call to _handshake() someone may\n            // call publish() (or other methods that call _queueSend()).\n            _internalBatch = true;\n\n            _delayedSend(function() {\n                _handshake(_handshakeProps, _handshakeCallback);\n            }, delay);\n        }\n\n        function _notifyCallback(callback, message) {\n            try {\n                callback.call(_cometd, message);\n            } catch (x) {\n                var handler = _cometd.onCallbackException;\n                if (_isFunction(handler)) {\n                    _cometd._debug('Invoking callback exception handler', x);\n                    try {\n                        handler.call(_cometd, x, message);\n                    } catch (xx) {\n                        _cometd._info('Exception during execution of callback exception handler', xx);\n                    }\n                } else {\n                    _cometd._info('Exception during execution of message callback', x);\n                }\n            }\n        }\n\n        this._getCallback = function(messageId) {\n            return _callbacks[messageId];\n        };\n\n        this._putCallback = function(messageId, callback) {\n            var result = this._getCallback(messageId);\n            if (_isFunction(callback)) {\n                _callbacks[messageId] = callback;\n            }\n            return result;\n        };\n\n        function _handleCallback(message) {\n            var callback = _cometd._getCallback([message.id]);\n            if (_isFunction(callback)) {\n                delete _callbacks[message.id];\n                _notifyCallback(callback, message);\n            }\n        }\n\n        function _handleRemoteCall(message) {\n            var context = _remoteCalls[message.id];\n            delete _remoteCalls[message.id];\n            if (context) {\n                _cometd._debug('Handling remote call response for', message, 'with context', context);\n\n                // Clear the timeout, if present.\n                var timeout = context.timeout;\n                if (timeout) {\n                    _cometd.clearTimeout(timeout);\n                }\n\n                var callback = context.callback;\n                if (_isFunction(callback)) {\n                    _notifyCallback(callback, message);\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        this.onTransportFailure = function(message, failureInfo, failureHandler) {\n            this._debug('Transport failure', failureInfo, 'for', message);\n\n            var transports = this.getTransportRegistry();\n            var url = this.getURL();\n            var crossDomain = this._isCrossDomain(_splitURL(url)[2]);\n            var version = '1.0';\n            var transportTypes = transports.findTransportTypes(version, crossDomain, url);\n\n            if (failureInfo.action === 'none') {\n                if (message.channel === '/meta/handshake') {\n                    if (!failureInfo.transport) {\n                        var failure = 'Could not negotiate transport, client=[' + transportTypes + '], server=[' + message.supportedConnectionTypes + ']';\n                        this._warn(failure);\n                        _notifyTransportException(_transport.getType(), null, {\n                            reason: failure,\n                            connectionType: _transport.getType(),\n                            transport: _transport\n                        });\n                    }\n                }\n            } else {\n                failureInfo.delay = this.getBackoffPeriod();\n                // Different logic depending on whether we are handshaking or connecting.\n                if (message.channel === '/meta/handshake') {\n                    if (!failureInfo.transport) {\n                        // The transport is invalid, try to negotiate again.\n                        var oldTransportType = _transport ? _transport.getType() : null;\n                        var newTransport = transports.negotiateTransport(transportTypes, version, crossDomain, url);\n                        if (!newTransport) {\n                            this._warn('Could not negotiate transport, client=[' + transportTypes + ']');\n                            _notifyTransportException(oldTransportType, null, message.failure);\n                            failureInfo.action = 'none';\n                        } else {\n                            var newTransportType = newTransport.getType();\n                            this._debug('Transport', oldTransportType, '->', newTransportType);\n                            _notifyTransportException(oldTransportType, newTransportType, message.failure);\n                            failureInfo.action = 'handshake';\n                            failureInfo.transport = newTransport;\n                        }\n                    }\n\n                    if (failureInfo.action !== 'none') {\n                        this.increaseBackoffPeriod();\n                    }\n                } else {\n                    var now = new Date().getTime();\n\n                    if (_unconnectTime === 0) {\n                        _unconnectTime = now;\n                    }\n\n                    if (failureInfo.action === 'retry') {\n                        failureInfo.delay = this.increaseBackoffPeriod();\n                        // Check whether we may switch to handshaking.\n                        var maxInterval = _advice.maxInterval;\n                        if (maxInterval > 0) {\n                            var expiration = _advice.timeout + _advice.interval + maxInterval;\n                            var unconnected = now - _unconnectTime;\n                            if (unconnected + _backoff > expiration) {\n                                failureInfo.action = 'handshake';\n                            }\n                        }\n                    }\n\n                    if (failureInfo.action === 'handshake') {\n                        failureInfo.delay = 0;\n                        transports.reset(false);\n                        this.resetBackoffPeriod();\n                    }\n                }\n            }\n\n            failureHandler.call(_cometd, failureInfo);\n        };\n\n        function _handleTransportFailure(failureInfo) {\n            _cometd._debug('Transport failure handling', failureInfo);\n\n            if (failureInfo.transport) {\n                _transport = failureInfo.transport;\n            }\n\n            if (failureInfo.url) {\n                _transport.setURL(failureInfo.url);\n            }\n\n            var action = failureInfo.action;\n            var delay = failureInfo.delay || 0;\n            switch (action) {\n                case 'handshake':\n                    _delayedHandshake(delay);\n                    break;\n                case 'retry':\n                    _delayedConnect(delay);\n                    break;\n                case 'none':\n                    _disconnect(true);\n                    break;\n                default:\n                    throw 'Unknown action ' + action;\n            }\n        }\n\n        function _failHandshake(message, failureInfo) {\n            _handleCallback(message);\n            _notifyListeners('/meta/handshake', message);\n            _notifyListeners('/meta/unsuccessful', message);\n\n            // The listeners may have disconnected.\n            if (_isDisconnected()) {\n                failureInfo.action = 'none';\n            }\n\n            _cometd.onTransportFailure.call(_cometd, message, failureInfo, _handleTransportFailure);\n        }\n\n        function _handshakeResponse(message) {\n            var url = _cometd.getURL();\n            if (message.successful) {\n                var crossDomain = _cometd._isCrossDomain(_splitURL(url)[2]);\n                var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, crossDomain, url);\n                if (newTransport === null) {\n                    message.successful = false;\n                    _failHandshake(message, {\n                        cause: 'negotiation',\n                        action: 'none',\n                        transport: null\n                    });\n                    return;\n                } else if (_transport !== newTransport) {\n                    _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());\n                    _transport = newTransport;\n                }\n\n                _clientId = message.clientId;\n\n                // End the internal batch and allow held messages from the application\n                // to go to the server (see _handshake() where we start the internal batch).\n                _internalBatch = false;\n                _flushBatch();\n\n                // Here the new transport is in place, as well as the clientId, so\n                // the listeners can perform a publish() if they want.\n                // Notify the listeners before the connect below.\n                message.reestablish = _reestablish;\n                _reestablish = true;\n\n                _handleCallback(message);\n                _notifyListeners('/meta/handshake', message);\n\n                _handshakeMessages = message['x-messages'] || 0;\n\n                var action = _isDisconnected() ? 'none' : _advice.reconnect || 'retry';\n                switch (action) {\n                    case 'retry':\n                        _resetBackoff();\n                        if (_handshakeMessages === 0) {\n                            _delayedConnect(0);\n                        } else {\n                            _cometd._debug('Processing', _handshakeMessages, 'handshake-delivered messages');\n                        }\n                        break;\n                    case 'none':\n                        _disconnect(true);\n                        break;\n                    default:\n                        throw 'Unrecognized advice action ' + action;\n                }\n            } else {\n                _failHandshake(message, {\n                    cause: 'unsuccessful',\n                    action: _advice.reconnect || 'handshake',\n                    transport: _transport\n                });\n            }\n        }\n\n        function _handshakeFailure(message) {\n            _failHandshake(message, {\n                cause: 'failure',\n                action: 'handshake',\n                transport: null\n            });\n        }\n\n        function _matchMetaConnect(connect) {\n            if (_status === 'disconnected') {\n                return true;\n            }\n            if (_metaConnect && _metaConnect.id === connect.id) {\n                _metaConnect = null;\n                return true;\n            }\n            return false;\n        }\n\n        function _failConnect(message, failureInfo) {\n            // Notify the listeners after the status change but before the next action.\n            _notifyListeners('/meta/connect', message);\n            _notifyListeners('/meta/unsuccessful', message);\n\n            // The listeners may have disconnected.\n            if (_isDisconnected()) {\n                failureInfo.action = 'none';\n            }\n\n            _cometd.onTransportFailure.call(_cometd, message, failureInfo, _handleTransportFailure);\n        }\n\n        function _connectResponse(message) {\n            if (_matchMetaConnect(message)) {\n                _connected = message.successful;\n                if (_connected) {\n                    _notifyListeners('/meta/connect', message);\n\n                    // Normally, the advice will say \"reconnect: 'retry', interval: 0\"\n                    // and the server will hold the request, so when a response returns\n                    // we immediately call the server again (long polling).\n                    // Listeners can call disconnect(), so check the state after they run.\n                    var action = _isDisconnected() ? 'none' : _advice.reconnect || 'retry';\n                    switch (action) {\n                        case 'retry':\n                            _resetBackoff();\n                            _delayedConnect(_backoff);\n                            break;\n                        case 'none':\n                            _disconnect(false);\n                            break;\n                        default:\n                            throw 'Unrecognized advice action ' + action;\n                    }\n                } else {\n                    _failConnect(message, {\n                        cause: 'unsuccessful',\n                        action: _advice.reconnect || 'retry',\n                        transport: _transport\n                    });\n                }\n            } else {\n                _cometd._debug('Mismatched /meta/connect reply', message);\n            }\n        }\n\n        function _connectFailure(message) {\n            if (_matchMetaConnect(message)) {\n                _connected = false;\n                _failConnect(message, {\n                    cause: 'failure',\n                    action: 'retry',\n                    transport: null\n                });\n            } else {\n                _cometd._debug('Mismatched /meta/connect failure', message);\n            }\n        }\n\n        function _failDisconnect(message) {\n            _disconnect(true);\n            _handleCallback(message);\n            _notifyListeners('/meta/disconnect', message);\n            _notifyListeners('/meta/unsuccessful', message);\n        }\n\n        function _disconnectResponse(message) {\n            if (message.successful) {\n                // Wait for the /meta/connect to arrive.\n                _disconnect(false);\n                _handleCallback(message);\n                _notifyListeners('/meta/disconnect', message);\n            } else {\n                _failDisconnect(message);\n            }\n        }\n\n        function _disconnectFailure(message) {\n            _failDisconnect(message);\n        }\n\n        function _failSubscribe(message) {\n            var subscriptions = _listeners[message.subscription];\n            if (subscriptions) {\n                for (var id in subscriptions) {\n                    if (subscriptions.hasOwnProperty(id)) {\n                        var subscription = subscriptions[id];\n                        if (subscription && !subscription.listener) {\n                            delete subscriptions[id];\n                            _cometd._debug('Removed failed subscription', subscription);\n                        }\n                    }\n                }\n            }\n            _handleCallback(message);\n            _notifyListeners('/meta/subscribe', message);\n            _notifyListeners('/meta/unsuccessful', message);\n        }\n\n        function _subscribeResponse(message) {\n            if (message.successful) {\n                _handleCallback(message);\n                _notifyListeners('/meta/subscribe', message);\n            } else {\n                _failSubscribe(message);\n            }\n        }\n\n        function _subscribeFailure(message) {\n            _failSubscribe(message);\n        }\n\n        function _failUnsubscribe(message) {\n            _handleCallback(message);\n            _notifyListeners('/meta/unsubscribe', message);\n            _notifyListeners('/meta/unsuccessful', message);\n        }\n\n        function _unsubscribeResponse(message) {\n            if (message.successful) {\n                _handleCallback(message);\n                _notifyListeners('/meta/unsubscribe', message);\n            } else {\n                _failUnsubscribe(message);\n            }\n        }\n\n        function _unsubscribeFailure(message) {\n            _failUnsubscribe(message);\n        }\n\n        function _failMessage(message) {\n            if (!_handleRemoteCall(message)) {\n                _handleCallback(message);\n                _notifyListeners('/meta/publish', message);\n                _notifyListeners('/meta/unsuccessful', message);\n            }\n        }\n\n        function _messageResponse(message) {\n            if (message.data !== undefined) {\n                if (!_handleRemoteCall(message)) {\n                    _notifyListeners(message.channel, message);\n                    if (_handshakeMessages > 0) {\n                        --_handshakeMessages;\n                        if (_handshakeMessages === 0) {\n                            _cometd._debug('Processed last handshake-delivered message');\n                            _delayedConnect(0);\n                        }\n                    }\n                }\n            } else {\n                if (message.successful === undefined) {\n                    _cometd._warn('Unknown Bayeux Message', message);\n                } else {\n                    if (message.successful) {\n                        _handleCallback(message);\n                        _notifyListeners('/meta/publish', message);\n                    } else {\n                        _failMessage(message);\n                    }\n                }\n            }\n        }\n\n        function _messageFailure(failure) {\n            _failMessage(failure);\n        }\n\n        function _receive(message) {\n            _unconnectTime = 0;\n\n            message = _applyIncomingExtensions(message);\n            if (message === undefined || message === null) {\n                return;\n            }\n\n            _updateAdvice(message.advice);\n\n            var channel = message.channel;\n            switch (channel) {\n                case '/meta/handshake':\n                    _handshakeResponse(message);\n                    break;\n                case '/meta/connect':\n                    _connectResponse(message);\n                    break;\n                case '/meta/disconnect':\n                    _disconnectResponse(message);\n                    break;\n                case '/meta/subscribe':\n                    _subscribeResponse(message);\n                    break;\n                case '/meta/unsubscribe':\n                    _unsubscribeResponse(message);\n                    break;\n                default:\n                    _messageResponse(message);\n                    break;\n            }\n        }\n\n        /**\n         * Receives a message.\n         * This method is exposed as a public so that extensions may inject\n         * messages simulating that they had been received.\n         */\n        this.receive = _receive;\n\n        _handleMessages = function(rcvdMessages) {\n            _cometd._debug('Received', rcvdMessages);\n\n            for (var i = 0; i < rcvdMessages.length; ++i) {\n                var message = rcvdMessages[i];\n                _receive(message);\n            }\n        };\n\n        _handleFailure = function(conduit, messages, failure) {\n            _cometd._debug('handleFailure', conduit, messages, failure);\n\n            failure.transport = conduit;\n            for (var i = 0; i < messages.length; ++i) {\n                var message = messages[i];\n                var failureMessage = {\n                    id: message.id,\n                    successful: false,\n                    channel: message.channel,\n                    failure: failure\n                };\n                failure.message = message;\n                switch (message.channel) {\n                    case '/meta/handshake':\n                        _handshakeFailure(failureMessage);\n                        break;\n                    case '/meta/connect':\n                        _connectFailure(failureMessage);\n                        break;\n                    case '/meta/disconnect':\n                        _disconnectFailure(failureMessage);\n                        break;\n                    case '/meta/subscribe':\n                        failureMessage.subscription = message.subscription;\n                        _subscribeFailure(failureMessage);\n                        break;\n                    case '/meta/unsubscribe':\n                        failureMessage.subscription = message.subscription;\n                        _unsubscribeFailure(failureMessage);\n                        break;\n                    default:\n                        _messageFailure(failureMessage);\n                        break;\n                }\n            }\n        };\n\n        function _hasSubscriptions(channel) {\n            var subscriptions = _listeners[channel];\n            if (subscriptions) {\n                for (var id in subscriptions) {\n                    if (subscriptions.hasOwnProperty(id)) {\n                        if (subscriptions[id]) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        function _resolveScopedCallback(scope, callback) {\n            var delegate = {\n                scope: scope,\n                method: callback\n            };\n            if (_isFunction(scope)) {\n                delegate.scope = undefined;\n                delegate.method = scope;\n            } else {\n                if (_isString(callback)) {\n                    if (!scope) {\n                        throw 'Invalid scope ' + scope;\n                    }\n                    delegate.method = scope[callback];\n                    if (!_isFunction(delegate.method)) {\n                        throw 'Invalid callback ' + callback + ' for scope ' + scope;\n                    }\n                } else if (!_isFunction(callback)) {\n                    throw 'Invalid callback ' + callback;\n                }\n            }\n            return delegate;\n        }\n\n        function _addListener(channel, scope, callback, isListener) {\n            // The data structure is a map<channel, subscription[]>, where each subscription\n            // holds the callback to be called and its scope.\n\n            var delegate = _resolveScopedCallback(scope, callback);\n            _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);\n\n            var id = ++_listenerId;\n            var subscription = {\n                id: id,\n                channel: channel,\n                scope: delegate.scope,\n                callback: delegate.method,\n                listener: isListener\n            };\n\n            var subscriptions = _listeners[channel];\n            if (!subscriptions) {\n                subscriptions = {};\n                _listeners[channel] = subscriptions;\n            }\n\n            subscriptions[id] = subscription;\n\n            _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);\n\n            return subscription;\n        }\n\n        //\n        // PUBLIC API\n        //\n\n        /**\n         * Registers the given transport under the given transport type.\n         * The optional index parameter specifies the \"priority\" at which the\n         * transport is registered (where 0 is the max priority).\n         * If a transport with the same type is already registered, this function\n         * does nothing and returns false.\n         * @param type the transport type\n         * @param transport the transport object\n         * @param index the index at which this transport is to be registered\n         * @return true if the transport has been registered, false otherwise\n         * @see #unregisterTransport(type)\n         */\n        this.registerTransport = function(type, transport, index) {\n            var result = _transports.add(type, transport, index);\n            if (result) {\n                this._debug('Registered transport', type);\n\n                if (_isFunction(transport.registered)) {\n                    transport.registered(type, this);\n                }\n            }\n            return result;\n        };\n\n        /**\n         * Unregisters the transport with the given transport type.\n         * @param type the transport type to unregister\n         * @return the transport that has been unregistered,\n         * or null if no transport was previously registered under the given transport type\n         */\n        this.unregisterTransport = function(type) {\n            var transport = _transports.remove(type);\n            if (transport !== null) {\n                this._debug('Unregistered transport', type);\n\n                if (_isFunction(transport.unregistered)) {\n                    transport.unregistered();\n                }\n            }\n            return transport;\n        };\n\n        this.unregisterTransports = function() {\n            _transports.clear();\n        };\n\n        /**\n         * @return an array of all registered transport types\n         */\n        this.getTransportTypes = function() {\n            return _transports.getTransportTypes();\n        };\n\n        this.findTransport = function(name) {\n            return _transports.find(name);\n        };\n\n        /**\n         * @returns the TransportRegistry object\n         */\n        this.getTransportRegistry = function() {\n            return _transports;\n        };\n\n        /**\n         * Configures the initial Bayeux communication with the Bayeux server.\n         * Configuration is passed via an object that must contain a mandatory field <code>url</code>\n         * of type string containing the URL of the Bayeux server.\n         * @param configuration the configuration object\n         */\n        this.configure = function(configuration) {\n            _configure.call(this, configuration);\n        };\n\n        /**\n         * Configures and establishes the Bayeux communication with the Bayeux server\n         * via a handshake and a subsequent connect.\n         * @param configuration the configuration object\n         * @param handshakeProps an object to be merged with the handshake message\n         * @see #configure(configuration)\n         * @see #handshake(handshakeProps)\n         */\n        this.init = function(configuration, handshakeProps) {\n            this.configure(configuration);\n            this.handshake(handshakeProps);\n        };\n\n        /**\n         * Establishes the Bayeux communication with the Bayeux server\n         * via a handshake and a subsequent connect.\n         * @param handshakeProps an object to be merged with the handshake message\n         * @param handshakeCallback a function to be invoked when the handshake is acknowledged\n         */\n        this.handshake = function(handshakeProps, handshakeCallback) {\n            if (_status !== 'disconnected') {\n                throw 'Illegal state: handshaken';\n            }\n            _handshake(handshakeProps, handshakeCallback);\n        };\n\n        /**\n         * Disconnects from the Bayeux server.\n         * @param disconnectProps an object to be merged with the disconnect message\n         * @param disconnectCallback a function to be invoked when the disconnect is acknowledged\n         */\n        this.disconnect = function(disconnectProps, disconnectCallback) {\n            if (_isDisconnected()) {\n                return;\n            }\n\n            if (_isFunction(disconnectProps)) {\n                disconnectCallback = disconnectProps;\n                disconnectProps = undefined;\n            }\n\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/disconnect'\n            };\n            // Do not allow the user to override important fields.\n            var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, disconnectCallback);\n\n            _setStatus('disconnecting');\n            _send([message], false, 'disconnect');\n        };\n\n        /**\n         * Marks the start of a batch of application messages to be sent to the server\n         * in a single request, obtaining a single response containing (possibly) many\n         * application reply messages.\n         * Messages are held in a queue and not sent until {@link #endBatch()} is called.\n         * If startBatch() is called multiple times, then an equal number of endBatch()\n         * calls must be made to close and send the batch of messages.\n         * @see #endBatch()\n         */\n        this.startBatch = function() {\n            _startBatch();\n        };\n\n        /**\n         * Marks the end of a batch of application messages to be sent to the server\n         * in a single request.\n         * @see #startBatch()\n         */\n        this.endBatch = function() {\n            _endBatch();\n        };\n\n        /**\n         * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}\n         * and {@link #endBatch()} calls.\n         * @param scope the scope of the callback, may be omitted\n         * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls\n         */\n        this.batch = function(scope, callback) {\n            var delegate = _resolveScopedCallback(scope, callback);\n            this.startBatch();\n            try {\n                delegate.method.call(delegate.scope);\n                this.endBatch();\n            } catch (x) {\n                this._info('Exception during execution of batch', x);\n                this.endBatch();\n                throw x;\n            }\n        };\n\n        /**\n         * Adds a listener for bayeux messages, performing the given callback in the given scope\n         * when a message for the given channel arrives.\n         * @param channel the channel the listener is interested to\n         * @param scope the scope of the callback, may be omitted\n         * @param callback the callback to call when a message is sent to the channel\n         * @returns the subscription handle to be passed to {@link #removeListener(object)}\n         * @see #removeListener(subscription)\n         */\n        this.addListener = function(channel, scope, callback) {\n            if (arguments.length < 2) {\n                throw 'Illegal arguments number: required 2, got ' + arguments.length;\n            }\n            if (!_isString(channel)) {\n                throw 'Illegal argument type: channel must be a string';\n            }\n\n            return _addListener(channel, scope, callback, true);\n        };\n\n        /**\n         * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.\n         * @param subscription the subscription to unsubscribe.\n         * @see #addListener(channel, scope, callback)\n         */\n        this.removeListener = function(subscription) {\n            // Beware of subscription.id == 0, which is falsy => cannot use !subscription.id\n            if (!subscription || !subscription.channel || !(\"id\" in subscription)) {\n                throw 'Invalid argument: expected subscription, not ' + subscription;\n            }\n\n            _removeListener(subscription);\n        };\n\n        /**\n         * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or\n         * {@link #subscribe(channel, scope, callback)}.\n         */\n        this.clearListeners = function() {\n            _listeners = {};\n        };\n\n        /**\n         * Subscribes to the given channel, performing the given callback in the given scope\n         * when a message for the channel arrives.\n         * @param channel the channel to subscribe to\n         * @param scope the scope of the callback, may be omitted\n         * @param callback the callback to call when a message is sent to the channel\n         * @param subscribeProps an object to be merged with the subscribe message\n         * @param subscribeCallback a function to be invoked when the subscription is acknowledged\n         * @return the subscription handle to be passed to {@link #unsubscribe(object)}\n         */\n        this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {\n            if (arguments.length < 2) {\n                throw 'Illegal arguments number: required 2, got ' + arguments.length;\n            }\n            if (!_isString(channel)) {\n                throw 'Illegal argument type: channel must be a string';\n            }\n            if (_isDisconnected()) {\n                throw 'Illegal state: disconnected';\n            }\n\n            // Normalize arguments\n            if (_isFunction(scope)) {\n                subscribeCallback = subscribeProps;\n                subscribeProps = callback;\n                callback = scope;\n                scope = undefined;\n            }\n            if (_isFunction(subscribeProps)) {\n                subscribeCallback = subscribeProps;\n                subscribeProps = undefined;\n            }\n\n            // Only send the message to the server if this client has not yet subscribed to the channel\n            var send = !_hasSubscriptions(channel);\n\n            var subscription = _addListener(channel, scope, callback, false);\n\n            if (send) {\n                // Send the subscription message after the subscription registration to avoid\n                // races where the server would send a message to the subscribers, but here\n                // on the client the subscription has not been added yet to the data structures\n                var bayeuxMessage = {\n                    id: _nextMessageId(),\n                    channel: '/meta/subscribe',\n                    subscription: channel\n                };\n                // Do not allow the user to override important fields.\n                var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);\n\n                // Save the callback.\n                _cometd._putCallback(message.id, subscribeCallback);\n\n                _queueSend(message);\n            }\n\n            return subscription;\n        };\n\n        /**\n         * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.\n         * @param subscription the subscription to unsubscribe.\n         * @param unsubscribeProps an object to be merged with the unsubscribe message\n         * @param unsubscribeCallback a function to be invoked when the unsubscription is acknowledged\n         */\n        this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {\n            if (arguments.length < 1) {\n                throw 'Illegal arguments number: required 1, got ' + arguments.length;\n            }\n            if (_isDisconnected()) {\n                throw 'Illegal state: disconnected';\n            }\n\n            if (_isFunction(unsubscribeProps)) {\n                unsubscribeCallback = unsubscribeProps;\n                unsubscribeProps = undefined;\n            }\n\n            // Remove the local listener before sending the message\n            // This ensures that if the server fails, this client does not get notifications\n            this.removeListener(subscription);\n\n            var channel = subscription.channel;\n            // Only send the message to the server if this client unsubscribes the last subscription\n            if (!_hasSubscriptions(channel)) {\n                var bayeuxMessage = {\n                    id: _nextMessageId(),\n                    channel: '/meta/unsubscribe',\n                    subscription: channel\n                };\n                // Do not allow the user to override important fields.\n                var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);\n\n                // Save the callback.\n                _cometd._putCallback(message.id, unsubscribeCallback);\n\n                _queueSend(message);\n            }\n        };\n\n        this.resubscribe = function(subscription, subscribeProps) {\n            _removeSubscription(subscription);\n            if (subscription) {\n                return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);\n            }\n            return undefined;\n        };\n\n        /**\n         * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},\n         * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.\n         */\n        this.clearSubscriptions = function() {\n            _clearSubscriptions();\n        };\n\n        /**\n         * Publishes a message on the given channel, containing the given content.\n         * @param channel the channel to publish the message to\n         * @param content the content of the message\n         * @param publishProps an object to be merged with the publish message\n         * @param publishCallback a function to be invoked when the publish is acknowledged by the server\n         */\n        this.publish = function(channel, content, publishProps, publishCallback) {\n            if (arguments.length < 1) {\n                throw 'Illegal arguments number: required 1, got ' + arguments.length;\n            }\n            if (!_isString(channel)) {\n                throw 'Illegal argument type: channel must be a string';\n            }\n            if (/^\\/meta\\//.test(channel)) {\n                throw 'Illegal argument: cannot publish to meta channels';\n            }\n            if (_isDisconnected()) {\n                throw 'Illegal state: disconnected';\n            }\n\n            if (_isFunction(content)) {\n                publishCallback = content;\n                content = {};\n                publishProps = undefined;\n            } else if (_isFunction(publishProps)) {\n                publishCallback = publishProps;\n                publishProps = undefined;\n            }\n\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: channel,\n                data: content\n            };\n            // Do not allow the user to override important fields.\n            var message = this._mixin(false, {}, publishProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, publishCallback);\n\n            _queueSend(message);\n        };\n\n        /**\n         * Publishes a message with binary data on the given channel.\n         * The binary data chunk may be an ArrayBuffer, a DataView, a TypedArray\n         * (such as Uint8Array) or a plain integer array.\n         * The meta data object may contain additional application data such as\n         * a file name, a mime type, etc.\n         * @param channel the channel to publish the message to\n         * @param data the binary data to publish\n         * @param last whether the binary data chunk is the last\n         * @param meta an object containing meta data associated to the binary chunk\n         * @param callback a function to be invoked when the publish is acknowledged by the server\n         */\n        this.publishBinary = function(channel, data, last, meta, callback) {\n            if (_isFunction(data)) {\n                callback = data;\n                data = new ArrayBuffer(0);\n                last = true;\n                meta = undefined;\n            } else if (_isFunction(last)) {\n                callback = last;\n                last = true;\n                meta = undefined;\n            } else if (_isFunction(meta)) {\n                callback = meta;\n                meta = undefined;\n            }\n            var content = {\n                meta: meta,\n                data: data,\n                last: last\n            };\n            var ext = {\n                ext: {\n                    binary: {}\n                }\n            };\n            this.publish(channel, content, ext, callback);\n        };\n\n        this.remoteCall = function(target, content, timeout, callProps, callback) {\n            if (arguments.length < 1) {\n                throw 'Illegal arguments number: required 1, got ' + arguments.length;\n            }\n            if (!_isString(target)) {\n                throw 'Illegal argument type: target must be a string';\n            }\n            if (_isDisconnected()) {\n                throw 'Illegal state: disconnected';\n            }\n\n            if (_isFunction(content)) {\n                callback = content;\n                content = {};\n                timeout = _config.maxNetworkDelay;\n                callProps = undefined;\n            } else if (_isFunction(timeout)) {\n                callback = timeout;\n                timeout = _config.maxNetworkDelay;\n                callProps = undefined;\n            } else if (_isFunction(callProps)) {\n                callback = callProps;\n                callProps = undefined;\n            }\n\n            if (typeof timeout !== 'number') {\n                throw 'Illegal argument type: timeout must be a number';\n            }\n\n            if (!target.match(/^\\//)) {\n                target = '/' + target;\n            }\n            var channel = '/service' + target;\n\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: channel,\n                data: content\n            };\n            var message = this._mixin(false, {}, callProps, bayeuxMessage);\n\n            var context = {\n                callback: callback\n            };\n            if (timeout > 0) {\n                context.timeout = _cometd.setTimeout(function() {\n                    _cometd._debug('Timing out remote call', message, 'after', timeout, 'ms');\n                    _failMessage({\n                        id: message.id,\n                        error: '406::timeout',\n                        successful: false,\n                        failure: {\n                            message: message,\n                            reason: 'Remote Call Timeout'\n                        }\n                    });\n                }, timeout);\n                _cometd._debug('Scheduled remote call timeout', message, 'in', timeout, 'ms');\n            }\n            _remoteCalls[message.id] = context;\n\n            _queueSend(message);\n        };\n\n        this.remoteCallBinary = function(target, data, last, meta, timeout, callback) {\n            if (_isFunction(data)) {\n                callback = data;\n                data = new ArrayBuffer(0);\n                last = true;\n                meta = undefined;\n                timeout = _config.maxNetworkDelay;\n            } else if (_isFunction(last)) {\n                callback = last;\n                last = true;\n                meta = undefined;\n                timeout = _config.maxNetworkDelay;\n            } else if (_isFunction(meta)) {\n                callback = meta;\n                meta = undefined;\n                timeout = _config.maxNetworkDelay;\n            } else if (_isFunction(timeout)) {\n                callback = timeout;\n                timeout = _config.maxNetworkDelay;\n            }\n\n            var content = {\n                meta: meta,\n                data: data,\n                last: last\n            };\n            var ext = {\n                ext: {\n                    binary: {}\n                }\n            };\n\n            this.remoteCall(target, content, timeout, ext, callback);\n        };\n\n        /**\n         * Returns a string representing the status of the bayeux communication with the Bayeux server.\n         */\n        this.getStatus = function() {\n            return _status;\n        };\n\n        /**\n         * Returns whether this instance has been disconnected.\n         */\n        this.isDisconnected = _isDisconnected;\n\n        /**\n         * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n         * Default value is 1 second, which means if there is a persistent failure the retries will happen\n         * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of\n         * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).\n         * @param period the backoff period to set\n         * @see #getBackoffIncrement()\n         */\n        this.setBackoffIncrement = function(period) {\n            _config.backoffIncrement = period;\n        };\n\n        /**\n         * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n         * @see #setBackoffIncrement(period)\n         */\n        this.getBackoffIncrement = function() {\n            return _config.backoffIncrement;\n        };\n\n        /**\n         * Returns the backoff period to wait before retrying an unsuccessful or failed message.\n         */\n        this.getBackoffPeriod = function() {\n            return _backoff;\n        };\n\n        /**\n         * Increases the backoff period up to the maximum value configured.\n         * @returns the backoff period after increment\n         * @see getBackoffIncrement\n         */\n        this.increaseBackoffPeriod = function() {\n            return _increaseBackoff();\n        };\n\n        /**\n         * Resets the backoff period to zero.\n         */\n        this.resetBackoffPeriod = function() {\n            _resetBackoff();\n        };\n\n        /**\n         * Sets the log level for console logging.\n         * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n         * less verbose to more verbose.\n         * @param level the log level string\n         */\n        this.setLogLevel = function(level) {\n            _config.logLevel = level;\n        };\n\n        /**\n         * Registers an extension whose callbacks are called for every incoming message\n         * (that comes from the server to this client implementation) and for every\n         * outgoing message (that originates from this client implementation for the\n         * server).\n         * The format of the extension object is the following:\n         * <pre>\n         * {\n         *     incoming: function(message) { ... },\n         *     outgoing: function(message) { ... }\n         * }\n         * </pre>\n         * Both properties are optional, but if they are present they will be called\n         * respectively for each incoming message and for each outgoing message.\n         * @param name the name of the extension\n         * @param extension the extension to register\n         * @return true if the extension was registered, false otherwise\n         * @see #unregisterExtension(name)\n         */\n        this.registerExtension = function(name, extension) {\n            if (arguments.length < 2) {\n                throw 'Illegal arguments number: required 2, got ' + arguments.length;\n            }\n            if (!_isString(name)) {\n                throw 'Illegal argument type: extension name must be a string';\n            }\n\n            var existing = false;\n            for (var i = 0; i < _extensions.length; ++i) {\n                var existingExtension = _extensions[i];\n                if (existingExtension.name === name) {\n                    existing = true;\n                    break;\n                }\n            }\n            if (!existing) {\n                _extensions.push({\n                    name: name,\n                    extension: extension\n                });\n                this._debug('Registered extension', name);\n\n                // Callback for extensions\n                if (_isFunction(extension.registered)) {\n                    extension.registered(name, this);\n                }\n\n                return true;\n            } else {\n                this._info('Could not register extension with name', name, 'since another extension with the same name already exists');\n                return false;\n            }\n        };\n\n        /**\n         * Unregister an extension previously registered with\n         * {@link #registerExtension(name, extension)}.\n         * @param name the name of the extension to unregister.\n         * @return true if the extension was unregistered, false otherwise\n         */\n        this.unregisterExtension = function(name) {\n            if (!_isString(name)) {\n                throw 'Illegal argument type: extension name must be a string';\n            }\n\n            var unregistered = false;\n            for (var i = 0; i < _extensions.length; ++i) {\n                var extension = _extensions[i];\n                if (extension.name === name) {\n                    _extensions.splice(i, 1);\n                    unregistered = true;\n                    this._debug('Unregistered extension', name);\n\n                    // Callback for extensions\n                    var ext = extension.extension;\n                    if (_isFunction(ext.unregistered)) {\n                        ext.unregistered();\n                    }\n\n                    break;\n                }\n            }\n            return unregistered;\n        };\n\n        /**\n         * Find the extension registered with the given name.\n         * @param name the name of the extension to find\n         * @return the extension found or null if no extension with the given name has been registered\n         */\n        this.getExtension = function(name) {\n            for (var i = 0; i < _extensions.length; ++i) {\n                var extension = _extensions[i];\n                if (extension.name === name) {\n                    return extension.extension;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Returns the name assigned to this CometD object, or the string 'default'\n         * if no name has been explicitly passed as parameter to the constructor.\n         */\n        this.getName = function() {\n            return _name;\n        };\n\n        /**\n         * Returns the clientId assigned by the Bayeux server during handshake.\n         */\n        this.getClientId = function() {\n            return _clientId;\n        };\n\n        /**\n         * Returns the URL of the Bayeux server.\n         */\n        this.getURL = function() {\n            if (_transport) {\n                var url = _transport.getURL();\n                if (url) {\n                    return url;\n                }\n                url = _config.urls[_transport.getType()];\n                if (url) {\n                    return url;\n                }\n            }\n            return _config.url;\n        };\n\n        this.getTransport = function() {\n            return _transport;\n        };\n\n        this.getConfiguration = function() {\n            return this._mixin(true, {}, _config);\n        };\n\n        this.getAdvice = function() {\n            return this._mixin(true, {}, _advice);\n        };\n\n        this.setTimeout = function(funktion, delay) {\n            return _scheduler.setTimeout(function() {\n                try {\n                    _cometd._debug('Invoking timed function', funktion);\n                    funktion();\n                } catch (x) {\n                    _cometd._debug('Exception invoking timed function', funktion, x);\n                }\n            }, delay);\n        };\n\n        this.clearTimeout = function(id) {\n            _scheduler.clearTimeout(id);\n        };\n\n        // Initialize transports.\n        if (window.WebSocket) {\n            this.registerTransport('websocket', new WebSocketTransport());\n        }\n        this.registerTransport('long-polling', new LongPollingTransport());\n        this.registerTransport('callback-polling', new CallbackPollingTransport());\n    };\n\n    var _z85EncodeTable = [\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n        'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n        'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',\n        'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n        'Y', 'Z', '.', '-', ':', '+', '=', '^', '!', '/',\n        '*', '?', '&', '<', '>', '(', ')', '[', ']', '{',\n        '}', '@', '%', '$', '#'\n    ];\n    var _z85DecodeTable = [\n        0x00, 0x44, 0x00, 0x54, 0x53, 0x52, 0x48, 0x00,\n        0x4B, 0x4C, 0x46, 0x41, 0x00, 0x3F, 0x3E, 0x45,\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n        0x08, 0x09, 0x40, 0x00, 0x49, 0x42, 0x4A, 0x47,\n        0x51, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A,\n        0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,\n        0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A,\n        0x3B, 0x3C, 0x3D, 0x4D, 0x00, 0x4E, 0x43, 0x00,\n        0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,\n        0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,\n        0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,\n        0x21, 0x22, 0x23, 0x4F, 0x00, 0x50, 0x00, 0x00\n    ];\n    var Z85 = {\n        encode: function(bytes) {\n            var buffer = null;\n            if (bytes instanceof ArrayBuffer) {\n                buffer = bytes;\n            } else if (bytes.buffer instanceof ArrayBuffer) {\n                buffer = bytes.buffer;\n            } else if (Array.isArray(bytes)) {\n                buffer = new Uint8Array(bytes).buffer;\n            }\n            if (buffer == null) {\n                throw 'Cannot Z85 encode ' + bytes;\n            }\n\n            var length = buffer.byteLength;\n            var remainder = length % 4;\n            var padding = 4 - (remainder === 0 ? 4 : remainder);\n            var view = new DataView(buffer);\n            var result = '';\n            var value = 0;\n            for (var i = 0; i < length + padding; ++i) {\n                var isPadding = i >= length;\n                value = value * 256 + (isPadding ? 0 : view.getUint8(i));\n                if ((i + 1) % 4 === 0) {\n                    var divisor = 85 * 85 * 85 * 85;\n                    for (var j = 5; j > 0; --j) {\n                        if (!isPadding || j > padding) {\n                            var code = Math.floor(value / divisor) % 85;\n                            result += _z85EncodeTable[code];\n                        }\n                        divisor /= 85;\n                    }\n                    value = 0;\n                }\n            }\n\n            return result;\n        },\n        decode: function(string) {\n            var remainder = string.length % 5;\n            var padding = 5 - (remainder === 0 ? 5 : remainder);\n            for (var p = 0; p < padding; ++p) {\n                string += _z85EncodeTable[_z85EncodeTable.length - 1];\n            }\n            var length = string.length;\n\n            var buffer = new ArrayBuffer((length * 4 / 5) - padding);\n            var view = new DataView(buffer);\n            var value = 0;\n            var charIdx = 0;\n            var byteIdx = 0;\n            for (var i = 0; i < length; ++i) {\n                var code = string.charCodeAt(charIdx++) - 32;\n                value = value * 85 + _z85DecodeTable[code];\n                if (charIdx % 5 === 0) {\n                    var divisor = 256 * 256 * 256;\n                    while (divisor >= 1) {\n                        if (byteIdx < view.byteLength) {\n                            view.setUint8(byteIdx++, Math.floor(value / divisor) % 256);\n                        }\n                        divisor /= 256;\n                    }\n                    value = 0;\n                }\n            }\n\n            return buffer;\n        }\n    };\n\n    return {\n        CometD: CometD,\n        Transport: Transport,\n        RequestTransport: RequestTransport,\n        LongPollingTransport: LongPollingTransport,\n        CallbackPollingTransport: CallbackPollingTransport,\n        WebSocketTransport: WebSocketTransport,\n        Utils: Utils,\n        Z85: Z85\n    };\n}));\n","var __self__ = (function (root) {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = root.DOMException\n}\nF.prototype = root;\nreturn new F();\n})(typeof self !== 'undefined' ? self : this);\n(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  return exports;\n\n}({}));\n})(__self__);\ndelete __self__.fetch.polyfill\nexports = __self__.fetch // To enable: import fetch from 'cross-fetch'\nexports.default = __self__.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = __self__.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = __self__.Headers\nexports.Request = __self__.Request\nexports.Response = __self__.Response\nmodule.exports = exports\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import { Router } from 'utils';\n\n/**\n * Account API adapters -- account stuff TODO\n * @namespace accountAdapter\n */\n\nexport async function createAccount(optionals = {}) {\n    const { objectType = 'personal', name, shortName, adminKey, subscriptionPlan, billingInterval } = optionals;\n    const response = await new Router()\n        .post('/account', {\n            body: { objectType, name, shortName, adminKey, subscriptionPlan, billingInterval },\n        }).then(({ body }) => body);\n    return response;\n}\n\n// TODO -- just a copy-paste of create ATM; need to figuure out how to actually use\nexport async function updateAccount(optionals = {}) {\n    const { objectType = 'personal', name, shortName, adminKey, subscriptionPlan, billingInterval } = optionals;\n    const response = await new Router()\n        .patch('/account', {\n            body: { objectType, name, shortName, adminKey, subscriptionPlan, billingInterval },\n        }).then(({ body }) => body);\n    return response;\n}\n\nexport async function removeAccount(accountShortName) {\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .delete('/account')\n        .then(({ body }) => body);\n}","import { Router, identification } from 'utils';\nimport { cometdAdapter } from 'adapters';\n\n\n/**\n * Authentication API adapters -- for authentication\n * @namespace authAdapter\n */\n\n\n/**\n * Logs out of current Epicenter session.\n *\n * @memberof authAdapter\n * @example\n *\n * epicenter.authAdapter.logout()\n *\n * @returns {Promise}   Promise resolving to successful logout\n */\nexport async function logout() {\n    identification.session = undefined;\n    await cometdAdapter.disconnect();\n}\n\nexport async function login(options) {\n    const { handle, password, groupKey, objectType = 'user', ...others } = options;\n    const { accountShortName, projectShortName } = others;\n    const session = await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .post('/authentication', {\n            body: { objectType, handle, password, groupKey: groupKey || undefined },\n            includeAuthorization: false,\n            inert: true,\n        }).then(({ body }) => body);\n    await logout();\n\n    identification.session = session;\n    return session;\n}\n\nexport async function upgrade(groupKey, options) {\n    const { objectType = 'user', inert, ...others } = options;\n    const { accountShortName, projectShortName } = others;\n\n    const session = await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .patch('/authentication', {\n            body: { objectType, groupKey },\n            inert,\n        }).then(({ body }) => body);\n    await logout();\n\n    identification.session = session;\n    return session;\n}\n\nexport async function sso(options) {\n    const { accountShortName, projectShortName } = options;\n\n    const session = await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get('/registration/sso')\n        .then(({ body }) => body);\n\n    identification.session = session;\n    return session;\n}\n\nexport async function getSession() {\n    const { body } = await new Router().get('/authentication');\n\n    identification.session = body;\n    return body;\n}\n\nexport function getLocalSession() {\n    return identification.session;\n}\n","import { EpicenterError } from 'utils';\nimport { cometdAdapter } from 'adapters';\nimport { SCOPE_BOUNDARY, PUSH_CATEGORY } from 'utils/constants';\n\nconst validateScope = (scope) => {\n    if (!scope) throw new EpicenterError('No scope found where one was required');\n    const { scopeBoundary, scopeKey, pushCategory } = scope;\n    if (!scopeBoundary) throw new EpicenterError('Missing scope component: scopeBoundary');\n    if (!scopeKey) throw new EpicenterError('Missing scope component: scopeKey');\n    if (!pushCategory) throw new EpicenterError('Missing scope component: pushCategory');\n    if (!SCOPE_BOUNDARY.hasOwnProperty(scopeBoundary)) throw new EpicenterError(`Invalid scope boundary: ${scopeBoundary}`);\n    if (!PUSH_CATEGORY.hasOwnProperty(pushCategory)) throw new EpicenterError(`Invalid push category: ${pushCategory}`);\n};\n\n/** Channel thingy */\nexport default class Channel {\n\n    path;\n    update;\n    subscription;\n\n    /**\n     * Make a new channel\n     * @param {*} scope wordsd here\n     */\n    constructor(scope) {\n        const { scopeBoundary, scopeKey, pushCategory } = scope;\n        validateScope(scope);\n        this.path = `/${scopeBoundary.toLowerCase()}/${scopeKey}/${pushCategory.toLowerCase()}`;\n        if (cometdAdapter.subscriptions.has(this.path)) {\n            this.subscription = cometdAdapter.subscriptions.get(this.path);\n        }\n    }\n\n    /** This is the publis cahh\n     * @param {*} content someom\n     * @returns {Promise} something here\n     */\n    publish(content) {\n        return cometdAdapter.publish(this, content);\n    }\n\n    async subscribe(update, options) {\n        if (this.subscription) await this.unsubscribe();\n        this.update = update;\n        return cometdAdapter.add(this, update, options).then((subscription) => {\n            this.subscription = subscription;\n            return subscription;\n        });\n    }\n\n    async unsubscribe() {\n        if (this.subscription) {\n            await cometdAdapter.remove(this.subscription);\n            this.subscription = null;\n        }\n    }\n}\n\n\n","import AckExtension from 'cometd/AckExtension';\nimport ReloadExtension from 'cometd/ReloadExtension';\nimport { EpicenterError, identification, isBrowser, errorManager, config } from 'utils';\nimport { channelsEnabled } from 'adapters/project';\n\nconst AUTH_TOKEN_KEY = 'com.forio.epicenter.token';\n\nconst DISCONNECTED = 'disconnected';\nconst CONNECTED = 'connected';\n\n\nclass CometdError extends Error {\n    constructor(reply) {\n\n        super();\n        const { error, successful } = reply;\n        if (error && error.includes('403') && !successful) {\n            this.status = 401;\n        }\n        this.information = reply;\n        this.message = error;\n    }\n}\n\nclass CometdAdapter {\n\n    url;\n    customCometd;\n    defaultCometd;\n    initialization;\n    subscriptions = new Map();\n    state = DISCONNECTED;\n    requireAcknowledgement = true;\n\n    get cometd() {\n        return this.customCometd || this.defaultCometd;\n    }\n\n    async startup(options = { logLevel: 'error' }) {\n        const enabled = await channelsEnabled();\n        if (!enabled) throw new EpicenterError('Push Channels are not enabled on this project');\n        if (isBrowser()) {\n            const cometd = await import('cometd');\n            this.defaultCometd = new cometd.CometD();\n        }\n\n        const { apiProtocol, apiHost, apiVersion } = config;\n        this.url = `${apiProtocol}://${apiHost}/push/v${apiVersion}/cometd`;\n        this.cometd.registerExtension('ack', new AckExtension());\n        this.cometd.registerExtension('reload', new ReloadExtension());\n        this.cometd.configure({\n            url: this.url,\n            logLevel: options.logLevel,\n        });\n\n        if (isBrowser()) {\n            window.onunload = () => {\n                if (this.cometd.getStatus() === CONNECTED) {\n                    this.cometd.reload();\n                    this.cometd.getTransport().abort();\n                }\n            };\n        }\n    }\n\n    async reinit(customCometd, options) {\n        await this.disconnect();\n        this.initialization = undefined;\n        this.customCometd = customCometd;\n        return this.init(options);\n    }\n\n    async init(options) {\n        if (!this.initialization) {\n            this.initialization = this.startup(options);\n        }\n        return this.initialization;\n    }\n\n    // Connects to CometD server\n    async handshake(options = {}) {\n        await this.init();\n\n        if (this.cometd.getStatus() !== DISCONNECTED) {\n            return Promise.resolve();\n        }\n\n        const handshakeProps = {};\n        const { session } = identification;\n\n        if (session) {\n            handshakeProps.ext = {\n                [AUTH_TOKEN_KEY]: session.token,\n                ack: this.requireAcknowledgement,\n            };\n        }\n\n        this.cometd.ackEnabled = this.requireAcknowledgement;\n        this.cometd.websocketEnabled = true;\n        return new Promise((resolve, reject) => this.cometd.handshake(handshakeProps, (handshakeReply) => {\n            if (handshakeReply.successful) {\n                resolve(handshakeReply);\n                return;\n            }\n\n            const error = new CometdError(handshakeReply);\n\n            if (options.inert) {\n                reject(error);\n                return;\n            }\n\n            const retry = () => this.handshake({ inert: true });\n            try {\n                const result = errorManager.handle(error, retry);\n                resolve(result);\n            } catch (e) {\n                reject(e);\n            }\n        }));\n    }\n\n    async disconnect() {\n        if (!this.cometd) return Promise.resolve();\n\n        await this.init();\n        await this.empty();\n        if (this.cometd.getStatus() !== CONNECTED) return Promise.resolve();\n\n        return new Promise((resolve, reject) => this.cometd.disconnect((disconnectReply) => {\n            if (!disconnectReply.successful) {\n                reject(new EpicenterError('Unable to disconnect from CometD server'));\n            } else {\n                resolve();\n            }\n        }));\n    }\n\n    async add(channel, update, options = {}) {\n        await this.init();\n        const channels = [].concat(channel);\n\n        if (this.cometd.getStatus() !== CONNECTED) {\n            await this.handshake();\n        }\n        const subscriptionProps = {};\n        const { session } = identification;\n        if (session) {\n            subscriptionProps.ext = { [AUTH_TOKEN_KEY]: session.token };\n        }\n\n        const handleCometdUpdate = ({ channel, data }) => {\n            data = typeof data === 'string' ? JSON.parse(data) : data;\n            return update(data);\n        };\n        const promises = [];\n        this.cometd.batch(() => channels.forEach(({ path }) => promises.push(new Promise((resolve, reject) => {\n            const subscription = this.cometd.subscribe(path, handleCometdUpdate, subscriptionProps, (subscribeReply) => {\n                if (subscribeReply.successful) {\n                    this.subscriptions.set(subscription.channel, subscription);\n                    resolve(subscription);\n                    return;\n                }\n\n                const error = new CometdError(subscribeReply);\n\n                if (options.inert) {\n                    reject(error);\n                    return;\n                }\n\n                const retry = () => this.add(channel, update, { inert: true });\n                try {\n                    const result = errorManager.handle(error, retry);\n                    resolve(result);\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        }))));\n        return promises.length === 1 ?\n            Promise.all(promises).then(([res]) => res) :\n            Promise.all(promises);\n    }\n\n    async publish(channel, content, options = {}) {\n        await this.init();\n        const channels = [].concat(channel);\n\n        if (this.cometd.getStatus() !== CONNECTED) {\n            await this.handshake();\n        }\n        const publishProps = {};\n        const { session } = identification;\n        if (session) {\n            publishProps.ext = { [AUTH_TOKEN_KEY]: session.token };\n        }\n        const promises = [];\n        this.cometd.batch(() => channels.forEach(({ path }) => promises.push(new Promise((resolve, reject) => {\n            this.cometd.publish(path, content, publishProps, (publishReply) => {\n                if (publishReply.successful) {\n                    resolve(publishReply);\n                    return;\n                }\n\n                const error = new CometdError(publishReply);\n\n                if (options.inert) {\n                    reject(error);\n                    return;\n                }\n\n                const retry = () => this.publish(channel, content, { inert: true });\n                try {\n                    const result = errorManager.handle(error, retry);\n                    resolve(result);\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        }))));\n        return promises.length === 1 ?\n            Promise.all(promises).then(([res]) => res) :\n            Promise.all(promises);\n    }\n\n    async remove(subscription) {\n        await this.init();\n        this.subscriptions.delete(subscription.channel);\n        return new Promise((resolve, reject) => this.cometd.unsubscribe(subscription, (unsubscribeReply) => {\n            if (unsubscribeReply.successful) {\n                resolve(unsubscribeReply);\n            }\n            const error = new CometdError(unsubscribeReply);\n            reject(error);\n            /* Not using error handling here yet -- should we? */\n        }));\n    }\n\n    async empty() {\n        await this.init();\n        const promises = [];\n        this.cometd.batch(() => this.subscriptions.forEach((subscription) => {\n            promises.push(this.remove(subscription));\n        }));\n        return Promise.all(promises);\n    }\n}\nconst cometdAdapter = new CometdAdapter();\nexport default cometdAdapter;\n\n","import { Router } from 'utils';\n\n/**\n * Episode API adapters -- use this to create, update, delete, and manage your episodes\n * @namespace episodeAdapter\n */\n\n\n/**\n * Create an episode.\n *\n * TODO -- add meaningful text here\n * @memberof episodeAdapter\n * @example\n *\n * import { episodeAdapter } from 'epicenter';\n * episodeAdapter.create('myEpisode', 'myGroupName', {\n *      runLimit: 20,\n *      draft: true,\n * });\n * @param {string}  name                Episode name\n * @param {object}  groupName           Group to make the episode under\n * @param {object}  [optionals={}]      Something meaningful about optionals\n * @returns {object}                    Something meaningful about returns\n */\nexport async function create(name, groupName, optionals = {}) {\n    const { accountShortName, projectShortName, draft, runLimit } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .post(`/episode/${groupName}`, {\n            body: { name, draft, runLimit },\n        }).then(({ body }) => body);\n}\n\n/**\n * Gets episodes.\n *\n * TODO -- add meaningful text here\n * @memberof episodeAdapter\n * @example\n *\n * import { episodeAdapter } from 'epicenter';\n * episodeAdapter.get('123124141241);\n *\n * @param {string}  episodeKey          The episode key\n * @param {object}  [optionals={}]      Something meaningful about optionals\n * @returns {object}                    Something meaningful about returns\n */\nexport async function get(episodeKey, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get(`/episode/${episodeKey}`)\n        .then(({ body }) => body);\n}\n\n/**\n * Gets episodes.\n *\n * TODO -- add meaningful text here\n * @memberof episodeAdapter\n * @example\n *\n * import { episodeAdapter } from 'epicenter';\n * episodeAdapter.get();\n * episodeAdapter.get({ episodeKey: 12321 });\n * episodeAdapter.get({ groupName: 'myGroupName', episodeName: 'myEpisodeName' });\n *\n * @param {object}  [optionals={}]      Something meaningful about optionals\n * @returns {object}                    Something meaningful about returns\n */\nexport async function query(optionals = {}) {\n    const {\n        accountShortName, projectShortName,\n        filter = [], sort = [], first = 0, max = 100,\n    } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams({\n            filter: filter.join(';'),\n            sort: sort.join(';'),\n            first, max,\n        })\n        .get('/episode/search')\n        .then(({ body }) => body);\n}\n\n/**\n * Gets episodes.\n *\n * TODO -- add meaningful text here\n * @memberof episodeAdapter\n * @example\n *\n * import { episodeAdapter } from 'epicenter';\n * episodeAdapter.withGroup('1231241342345');\n *\n * @param {string}  groupKey            The group key\n * @param {object}  [optionals={}]      Something meaningful about optionals\n * @returns {object}                    Something meaningful about returns\n */\nexport async function forGroup(groupKey, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get(`/episode/in/${groupKey}`)\n        .then(({ body }) => body);\n}\n\n/**\n * Gets episode based on group name and episode name\n * Unsure where this would see use...\n *\n * TODO -- add meaningful text here\n * @memberof episodeAdapter\n * @example\n *\n * import { episodeAdapter } from 'epicenter';\n * episodeAdapter.withName('myGroupName', 'myEpisodeName');\n *\n * @param {string}  groupName           The group name\n * @param {string}  episodeName         The episode name\n * @param {object}  [optionals={}]      Something meaningful about optionals\n * @returns {object}                    Something meaningful about returns\n */\nexport async function byName(groupName, episodeName, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get(`/episode/with/${groupName}/${episodeName}`)\n        .then(({ body }) => body);\n}\n\n/**\n * Deletes an episode\n *\n * TODO -- add meaningful text here\n * @memberof episodeAdapter\n * @example\n *\n * import { episodeAdapter } from 'epicenter';\n * const episodeKey = 1234;\n * episodeAdapter.remove(episodeKey);\n *\n * @param {string}  episodeKey          Something meaningful about optionals\n * @param {object}  [optionals={}]      Something meaningful about optionals\n * @returns {object}                    Something meaningful about returns\n */\nexport async function remove(episodeKey, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .delete(`/episode/${episodeKey}`)\n        .then(({ body }) => body);\n}\n","import { Router, EpicenterError } from 'utils';\nimport { LOCK_TYPE } from 'utils/constants';\n\n/**\n * Group API adapters -- handles groups and group memberships\n * @namespace groupAdapter\n */\n\n\n/**\n * Provides information on a particular Epicenter group.\n *\n * Base URL: GET `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/group[/:member]/{GROUP_KEY}`\n *\n * @memberof groupAdapter\n * @example\n *\n * import { authAdapter, groupAdapter } from 'epicenter';\n * const session = authAdapter.getLocalSession();\n * const group = await groupAdapter.get(session.groupKey, {\n *      augment: 'MEMBERS'      // include members of the group in return\n * });\n *\n * @param {string}  groupKey                        Key associated with group\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.augment]             Augments the GET request to return additional information, one of [MEMBERS, QUANTIZED]\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                Group object\n */\nexport async function get(groupKey, optionals = {}) {\n    const { accountShortName, projectShortName, augment } = optionals;\n    let uriComponent = '';\n    if (augment === 'MEMBERS') uriComponent = '/member';\n    if (augment === 'QUANTIZED') uriComponent = '/quantized';\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get(`/group${uriComponent}/${groupKey}`)\n        .then(({ body }) => body);\n}\n\n\n/**\n * Deletes the group; available only to Epicenter admins\n *\n * Base URL: DELETE `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/group/{GROUP_KEY}`\n *\n * @memberof groupAdapter\n * @example\n *\n * epicenter.groupAdapter.destroy(group.groupKey);\n *\n * @param {string}  groupKey                        Key associated with group\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {undefined}\n */\nexport async function destroy(groupKey, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .delete(`/group/${groupKey}`)\n        .then(({ body }) => body);\n}\n\n\n/**\n * Provides information on for all groups in the project\n *\n * Base URL: GET `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/group?expired={BOOLEAN}`\n *\n * @memberof groupAdapter\n * @example\n *\n * const groups = await epicenter.groupAdapter.gather();\n *\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {boolean} [optionals.expired]             Indicates whether to include expired groups in the query\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object[]}                              List of groups\n */\nexport async function gather(optionals = {}) {\n    const { accountShortName, projectShortName, expired } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams({ expired })\n        .get('/group')\n        .then(({ body }) => body);\n}\n\n\n/**\n * Updates fields for a particular group; available only to Epicenter admins.\n *\n * Base URL: PATCH `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/group/{GROUP_KEY}`\n *\n * @memberof groupAdapter\n * @example\n *\n * epicenter.groupAdapter.update(groupKey, { event: 'Orientation Day' });\n *\n * @param {string}  groupKey                        Key associated with group\n * @param {object}  update                          Attributes you wish to update\n * @param {number}  update.runLimit                 Defines the upper limit of runs allowed in the group\n * @param {string}  update.organization             Name of the organization owning the group\n * @param {boolean} update.allowSelfRegistration    TODO\n * @param {object}  update.flightRecorder           TODO\n * @param {number}  update.flightRecorder.start     TODO\n * @param {number}  update.flightRecorder.stop      TODO\n * @param {boolean} update.flightRecorder.enabled   TODO\n * @param {string}  update.event                    Name of the event the group is playing for\n * @param {boolean} update.allowMembershipChanges   TODO\n * @param {object}  update.pricing                  TODO\n * @param {object}  update.startDate                TODO\n * @param {object}  update.expirationDate           TODO\n * @param {object}  update.capacity                 Defines the upper limit on the number of users allowed in the group\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                Group with updated attributes\n */\nexport async function update(groupKey, update, optionals = {}) {\n    const {\n        runLimit, organization, allowSelfRegistration, flightRecorder,\n        event, allowMembershipChanges, pricing,\n        startDate, expirationDate, capacity,\n    } = update;\n    const { accountShortName, projectShortName } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .patch(`/group/${groupKey}`, {\n            body: {\n                runLimit, organization, allowSelfRegistration, flightRecorder,\n                event, allowMembershipChanges, pricing,\n                startDate, expirationDate, capacity,\n            },\n        })\n        .then(({ body }) => body);\n}\n\n\n/**\n * Creates a new group; available only to Epicenter admins\n *\n * Base URL: POST `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/group`\n *\n * @memberof groupAdapter\n * @example\n *\n * epicenter.groupAdapter.create({\n *      runLimit: 10,\n *      name: 'my-group-name',\n * });\n *\n * @param {object}  group                           Group object\n * @param {string}  group.name                      Group name (required)\n * @param {number}  group.runLimit                  Defines the upper limit on the number of runs allowed in the group\n * @param {string}  group.organization              Name of the organization owning the group\n * @param {string}  group.allowSelfRegistration     TODO\n * @param {object}  group.flightRecorder            TODO\n * @param {number}  group.flightRecorder.start      TODO\n * @param {number}  group.flightRecorder.stop       TODO\n * @param {boolean} group.flightRecorder.enabled    TODO\n * @param {string}  group.event                     Name of the event the group is playing for\n * @param {boolean} group.allowMembershipChanges    TODO\n * @param {object}  group.pricing                   TODO\n * @param {object}  group.startDate                 TODO\n * @param {object}  group.expirationDate            TODO\n * @param {object}  group.capacity                  Defines the upper limit on the number of users allowed in the group\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                Newly created group\n */\nexport async function create(group, optionals = {}) {\n    const {\n        name, runLimit, organization, allowSelfRegistration,\n        flightRecorder, event, allowMembershipChanges, pricing,\n        startDate, expirationDate, capacity,\n    } = group;\n    const { accountShortName, projectShortName } = optionals;\n    if (!name) throw new EpicenterError('Cannot create a group with no name');\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .post('/group', {\n            body: {\n                name, runLimit, organization, allowSelfRegistration,\n                flightRecorder, event, allowMembershipChanges, pricing,\n                startDate, expirationDate, capacity,\n            },\n        })\n        .then(({ body }) => body);\n}\n\n\n/**\n * Queries for groups\n *\n * Base URL: GET `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/group/search?filter={FILTER}&sort={SORT}&first={FIRST}&max={MAX}`\n *\n * @memberof groupAdapter\n * @example\n *\n * import { groupAdapter } from 'epicenter';\n * groupAdapter.search({\n *      filter: [\n *          'group.name|=group1|group2',    // look for groups whose name is 'group1' or 'group2'\n *          'permission.role=FACILITATOR',  // where there exists at least one facilitator user\n *          'user.userKey=0123',            // whose userKey is '0123'\n *      },\n *      sort: ['+group.name']               // sort all findings by group name ascending (lexigraphically)\n * });\n *\n * @param {object}      [optionals={}]                  Optional parameters\n * @param {string[]}    [optionals.filter]              List of conditionals to filter for\n * @param {string[]}    [optionals.sort]                List of values to sort by\n * @param {string}      [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}      [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                    Group object\n */\nexport async function search(optionals = {}) {\n    const {\n        filter = [], sort = [], first, max, quantized,\n        accountShortName, projectShortName,\n    } = optionals;\n\n    const searchParams = {\n        filter: filter.join(';') || undefined,\n        sort: sort.join(';') || undefined,\n        first, max,\n    };\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams(searchParams)\n        .get(`/group${quantized ? '/quantized' : ''}/search`, { paginated: true })\n        .then(({ body }) => body);\n}\n\n\n/**\n * Retrieves a group with given group name\n *\n * Base URL: GET `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/group/with/{GROUP_NAME}`\n *\n * @memberof groupAdapter\n * @example\n *\n * epicenter.groupAdapter.withGroupName(group.groupKey)\n *\n * @param {string}  name                            Name associated with the group\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                Group Object\n */\nexport async function withGroupName(name, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get(`/group/with/${name}`)\n        .then(({ body }) => body);\n}\n\n\n/**\n * Retrieves the list of groups a particular user is in; intended for admin use\n *\n * Base URL: GET `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/group/member/for/{USER_KEY}[?expired={BOOLEAN}&all={BOOLEAN}&role={ROLE}&role={ROLE}...]`\n *\n * @memberof groupAdapter\n * @example\n *\n * epicenter.groupAdapter.forUserKey(\n *      user.userKey,               // get groups where this user is a member of\n *      { role: ['FACILITATOR'] }   // where this user is a facilitator in the group\n * );\n *\n * @param {string}          userKey                         Name associated with the group\n * @param {object}          [optionals={}]                  Optional parameters\n * @param {boolean}         [optionals.expired]             Indicates whether to include expired groups in the query\n * @param {boolean}         [optionals.all]                 Indicates whether to include the other members in the group (by default, only the requested user appears)\n * @param {string|string[]} [optionals.role]                Role or list of possible roles the user holds in the group\n * @param {string}          [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}          [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object[]}                                      List of groups\n */\nexport async function forUserKey(userKey, optionals = {}) {\n    const {\n        expired, all, role,\n        accountShortName, projectShortName,\n    } = optionals;\n    const isMultiple = Array.isArray(role) && role.length > 0;\n    const roleList = isMultiple ? role : [role];\n    const searchParams = {\n        expired,\n        all,\n        role: role ? roleList : undefined,\n    };\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams(searchParams)\n        .get(`/group/member/for/${userKey}`)\n        .then(({ body }) => body);\n}\n\n\n/**\n * Retrieves the list of groups particular to the current session\n *\n * Base URL: GET `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/group/member[?expired={BOOLEAN}&role={ROLE}&role={ROLE}...]`\n *\n * @memberof groupAdapter\n * @example\n *\n * const groups = await epicenter.groupAdapter.getSessionGroups();\n *\n * @param {object}          [optionals={}]                  Optional parameters\n * @param {boolean}         [optionals.expired]             Indicates whether to include expired groups in the query (defaults to false)\n * @param {string|string[]} [optionals.role]                Role or list of possible roles the user holds in the group\n * @param {string}          [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}          [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object[]}                                      List of groups\n */\nexport async function getSessionGroups(optionals = {}) {\n    const {\n        expired, role,\n        accountShortName, projectShortName,\n    } = optionals;\n    const isMultiple = Array.isArray(role) && role.length > 0;\n    const roleList = isMultiple ? role : [role];\n    const searchParams = {\n        expired,\n        role: role ? roleList : undefined,\n    };\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams(searchParams)\n        .get('/group/member')\n        .then(({ body }) => body);\n}\n\n\n/**\n * Self-application for membership in a group; will only work if the group has the self-registration setting turned on.\n *\n * Base URL: POST `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/group/selfRegistration/{GROUP_KEY}`\n *\n * @memberof groupAdapter\n * @example\n *\n * epicenter.groupAdapter.register(group.groupKey);\n *\n * @param {string}          groupKey                        Key associated with group\n * @param {object}          [optionals={}]                  Optional parameters\n * @param {string}          [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}          [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object[]}                                      List of groups\n */\nexport async function register(groupKey, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n    // TODO figure stufffffffff\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .post(`/group/selfRegistration/${groupKey}`)\n        .then(({ body }) => body);\n}\n\n\n/**\n * Adds a user to a group\n *\n * Base URL: POST `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/group/member/{GROUP_KEY}`\n *\n * @memberof groupAdapter\n * @example\n *\n * epicenter.groupAdapter.addUser(group.groupKey);\n *\n * @param {string}          groupKey                        Key associated with group\n * @param {string}          userKey                         Key associated with group\n * @param {object}          [optionals={}]                  Optional parameters\n * @param {string}          [optionals.role]                User's role -- defaults to PARTICIPANT if unset; See [LOCK_TYPE](#LOCK_TYPE) for all types\n * @param {string}          [optionals.available]           Indicates whether or not the user is 'active' (for semantic labeling) -- defaults to true if unset\n * @param {string}          [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}          [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                        Group the user was added to\n */\nexport async function addUser(groupKey, userKey, optionals = {}) {\n    const {\n        role, available,\n        accountShortName, projectShortName,\n    } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .post(`/group/member/${groupKey}`, {\n            body: {\n                objectType: 'group',\n                userKey,\n                role: role ?? LOCK_TYPE.PARTICIPANT,\n                available: available ?? true,\n            },\n        })\n        .then(({ body }) => body);\n}\n\n\n/**\n * Updates a user's group membership information\n *\n * Base URL: PATCH `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/group/member/{GROUP_KEY}/{USER_KEY}`\n *\n * @memberof groupAdapter\n * @example\n *\n * epicenter.groupAdapter.updateUser(group.groupKey);\n *\n * @param {string}          groupKey                        Key associated with group\n * @param {string}          userKey                         Key associated with group\n * @param {object}          [optionals={}]                  Optional parameters\n * @param {string}          [optionals.role]                User's role; See [LOCK_TYPE](#LOCK_TYPE) for all types\n * @param {string}          [optionals.available]           Indicates whether or not the user is 'active' (for semantic labeling)\n * @param {string}          [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}          [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                        Group the user was added to\n */\nexport async function updateUser(groupKey, userKey, optionals = {}) {\n    const {\n        role, available,\n        accountShortName, projectShortName,\n    } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .patch(`/group/member/${groupKey}/${userKey}`, {\n            body: {\n                objectType: 'group',\n                role,\n                available,\n            },\n        })\n        .then(({ body }) => body);\n}\n\n\n/**\n * Removes user(s) from the group\n *\n * Base URL: DELETE `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/group/member/{GROUP_KEY}[/{USER_KEY}][?userKey={USER_KEY}&userKey=...]`\n *\n * @memberof groupAdapter\n * @example\n *\n * const userKeys = members.map(({ userKey }) => userKey);\n * epicenter.groupAdapter.removeUsers(group.groupKey, userKeys)\n *\n * @param {string}          groupKey                        Key associated with the group\n * @param {string|string[]} userKey                         Key associated with the user or an array of user keys to remove from group\n * @param {object}          [optionals={}]                  Optional parameters\n * @param {string}          [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}          [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {undefined}\n */\nexport async function removeUser(groupKey, userKey, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n    const hasMultiple = Array.isArray(userKey) && userKey.length > 1;\n    const uriComponent = hasMultiple ? '' : `/${userKey.length === 1 ? userKey[0] : userKey}`;\n    const searchParams = hasMultiple ? { userKey } : undefined;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams(searchParams)\n        .delete(`/group/member/${groupKey}${uriComponent}`)\n        .then(({ body }) => body);\n}\n\n","import * as accountAdapter from './account';\nimport * as authAdapter from './authentication';\nimport * as episodeAdapter from './episode';\nimport * as groupAdapter from './group';\nimport * as presenceAdapter from './presence';\nimport * as projectAdapter from './project';\nimport * as runAdapter from './run';\nimport * as vaultAdapter from './vault';\nimport * as worldAdapter from './world';\nimport { default as cometdAdapter } from './cometd';\nimport { default as Channel } from './channel';\n\nexport {\n    accountAdapter,\n    authAdapter,\n    cometdAdapter,\n    episodeAdapter,\n    groupAdapter,\n    presenceAdapter,\n    projectAdapter,\n    runAdapter,\n    vaultAdapter,\n    worldAdapter,\n    Channel,\n};\n","import { Router } from 'utils';\nimport { cometdAdapter } from 'adapters';\n\n\n/**\n * Presence API adapters -- use this to track online/offline users\n * @namespace presenceAdapter\n */\n\n\n/**\n * Makes a connection request to the cometd server; effectively marking the user as online; using [logout](#authAdapter-logout) will automatically disconnect for you.\n *\n * @memberof presenceAdapter\n * @example\n *\n * epicenter.presenceAdapter.forWorld(world.worldKey)\n *\n * @returns {Promise}   Promise indicating whether or not the connection was successful\n */\nexport async function connect() {\n    return cometdAdapter.handshake();\n}\n\n\n/**\n * Retrieves the presence information for a particular group\n *\n * Base URL: GET `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/presence/group/{GROUP_KEY}`\n *\n * @memberof presenceAdapter\n * @example\n *\n * epicenter.presenceAdapter.forGroup(group.groupKey)\n *\n * @param {string}  groupKey                        Key associated with group\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                List of users online\n */\nexport async function forGroup(groupKey, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get(`/presence/group/${groupKey}`)\n        .then(({ body }) => body);\n}\n\n\n/**\n * Retrieves the presence information for a particular world\n *\n * Base URL: GET `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/presence/world/{WORLD_KEY}`\n *\n * @memberof presenceAdapter\n * @example\n *\n * epicenter.presenceAdapter.forWorld(world.worldKey)\n *\n * @param {string}  worldKey                        Key associated with world\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                List of users online\n */\nexport async function forWorld(worldKey, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get(`/presence/world/${worldKey}`)\n        .then(({ body }) => body);\n}\n\n","import { Router } from 'utils';\n\n\n/**\n * Project API adapters -- project stuff TODO\n * @namespace projectAdapter\n */\n\n\n/**\n * Makes a connection request to the cometd server; effectively marking the user as online; using [logout](#authAdapter-logout) will automatically disconnect for you.\n *\n * Base URL: GET `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/project/channel/isEnabled`\n *\n * @memberof projectAdapter\n * @example\n *\n * epicenter.projectAdapter.channelsEnabled()\n *\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {Promise}                               Promise resolving true/false whether or not the project supports the use of push channels\n */\nexport async function channelsEnabled(optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n    const response = await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get('/project/channel/isEnabled')\n        .then(({ body }) => body);\n\n    return response;\n}\n\n","import { EpicenterError, Router, identification } from 'utils';\nimport { LOCK_TYPE, SCOPE_BOUNDARY, RITUAL } from 'utils/constants';\n\n/**\n * Run API adapters -- use this to create, update, delete, and manage your runs\n * @namespace runAdapter\n */\n\n\n/**\n * Creates a run. By default, all runs are created with the user's ID (`userKey`) and user-only read-write permissions, except in the case of world-scoped runs. For more information on scopes,\n *\n * Base URL: POST `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/run`\n *\n * @memberof runAdapter\n * @example\n *\n * import { runAdapter, SCOPE_BOUNDARY } from 'epicenter';\n * runAdapter.create('model.py', {\n *      scopeBoundary: SCOPE_BOUNDARY.GROUP,\n *      scopeKey: '000001713a246b0b34b5b5d274c057a5b2a7'\n * });\n * @param {string}  model                           Name of your model file\n * @param {object}  scope                           Scope associated with your run\n * @param {string}  scope.scopeBoundary             Scope boundary, defines the type of scope; See [scope boundary](#SCOPE_BOUNDARY) for all types\n * @param {string}  scope.scopeKey                  Scope key, a unique identifier tied to the scope. E.g., if your `scopeBoundary` is `GROUP`, your `scopeKey` will be your `groupKey`; for `EPISODE`, `episodeKey`, etc.\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.readLock]            Role (character type)\n * @param {string}  [optionals.writeLock]           Role (chracter type)\n * @param {string}  [optionals.userKey]             Key of the user creating the run, should be `undefined` if it's a world run\n * @param {boolean} [optionals.ephemeral]           Used for testing. If true, the run will only exist so long as its in memory; makes it so that nothing is written to the database, history, or variables.\n * @param {string}  [optionals.trackingKey]         Tracking key\n * @param {object}  [optionals.modelContext]        .ctx2 file overrides, this is not tracked by clone operations\n * @param {object}  [optionals.executionContext]    Carries arguments for model file worker on model initialization. This is tracked by clone operations.\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                Newly created run\n */\nexport async function create(model, scope, optionals = {}) {\n    const { scopeBoundary, scopeKey } = scope;\n    const {\n        readLock, writeLock, userKey, ephemeral,\n        trackingKey, modelContext, executionContext,\n        accountShortName, projectShortName,\n    } = optionals;\n\n    const { WORLD } = SCOPE_BOUNDARY;\n    const { PARTICIPANT, USER } = LOCK_TYPE;\n    const defaultLock = scopeBoundary === WORLD ? PARTICIPANT : USER;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .post('/run', {\n            body: {\n                scope: {\n                    scopeBoundary,\n                    scopeKey,\n                    userKey: scopeBoundary === WORLD ?\n                        undefined :\n                        userKey ?? identification.session.userKey,\n                },\n                permit: {\n                    readLock: readLock || defaultLock,\n                    writeLock: writeLock || defaultLock,\n                },\n                morphology: 'MANY',\n                trackingKey,\n                modelFile: model,\n                modelContext: modelContext || {/* Is not recorded for clone. Overrides model ctx2 file. */},\n                executionContext: executionContext || {/* Affected by clone. Carries arguments for model file worker on model initialization */},\n                ephemeral,\n            },\n        }).then(({ body }) => body);\n}\n\n/**\n * Clone a run\n * @memberof runAdapter\n *\n * @param {string}  runKey          Run's key\n * @param {object}  [optionals={}]  Object for all optional fields\n * @returns {object}                Response with the run in the \"body\"\n */\nexport async function clone(runKey, optionals = {}) {\n    const {\n        accountShortName, projectShortName, ephemeral,\n        trackingKey, modelContext = {}, executionContext = {},\n    } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .post(`/run/clone/${runKey}`, {\n            body: {\n                trackingKey,\n                modelContext,\n                executionContext,\n                ephemeral,\n            },\n        }).then(({ body }) => body);\n}\n\nexport async function restore(runKey, optionals = {}) {\n    const {\n        accountShortName, projectShortName, ephemeral,\n        modelContext = {}, executionContext = {},\n    } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .post(`/run/restore/${runKey}`, {\n            body: {\n                modelContext,\n                executionContext,\n                ephemeral,\n            },\n        }).then(({ body }) => body);\n}\n\nexport async function rewind(runKey, steps, optionals = {}) {\n    const {\n        accountShortName, projectShortName,\n        ephemeral, modelContext = {},\n    } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .post(`/run/rewind/${runKey}`, {\n            body: {\n                rewindCount: steps,\n                modelContext,\n                ephemeral,\n            },\n        }).then(({ body }) => body);\n}\n\nexport async function update(runKey, update, optionals = {}) {\n    const { readLock, writeLock, trackingKey, marked, hidden, closed } = update;\n    const { accountShortName, projectShortName } = optionals;\n    const hasMultiple = Array.isArray(runKey) && runKey.length > 1;\n    const uriComponent = hasMultiple ? '' : `/${runKey.length === 1 ? runKey[0] : runKey}`;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams(hasMultiple ? { runKey } : '')\n        .patch(`/run${uriComponent}`, {\n            body: {\n                readLock,\n                writeLock,\n                trackingKey,\n                marked,\n                hidden,\n                closed,\n            },\n        }).then(({ body }) => body);\n}\n\n\n/**\n * *Does not actually delete the run*. The run is instead removed from memory. This can be used as a means of preserving server CPUs, and should be used when you do not expect to perform any addtional actions that would bring the run back into memory. (TODO: see David for details; is it just operations that bring the run into memory? what about clone... etc.)\n *\n * Base URL: DELETE `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/run/{RUN_KEY}`\n *\n * @memberof runAdapter\n * @example\n *\n * epicenter.runAdapter.remove(run.runKey);\n *\n * @param {string}  runKey                          Key associated with the run\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                TODO\n */\nexport async function remove(runKey, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .delete(`/run/${runKey}`)\n        .then(({ body }) => body);\n}\n\nexport async function get(runKey, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get(`/run/${runKey}`)\n        .then(({ body }) => body);\n}\n\n\n/**\n * Queries for runs.\n *\n * Base URL: GET `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/run/{SCOPE_BOUNDARY}/{SCOPE_KEY}/{MODEL_FILE}?filter={FILTER}&sort={SORT}&first={FIRST}&max={MAX}`\n *\n * @memberof runAdapter\n * @example\n *\n * import { runAdapter } from 'epicenter';\n * runAdapter.query({\n *      filter: [\n *          'var.foo|=1|2|3',               // look for runs with a variable 'foo' with the values 1, 2, or 3\n *          'run.hidden=false',             // where the run's 'hidden' attribute is false\n *          'meta.classification~=bar-*'    // where the run metadata contains a 'classification' that begins with 'bar-'\n *      ],\n *      sort: ['+run.created']              // sort all findings by the 'created' field\n *      variables: ['foo', 'baz'],          // include the run variables for 'foo' and 'baz' in the response\n *      metadata: ['classification']        // include the run metadata for 'classification' in the response\n * });\n *\n * @param {string}      model                           Name of your model file\n * @param {object}      scope                           Scope associated with your run\n * @param {string}      scope.scopeBoundary             Scope boundary, defines the type of scope; See [scope boundary](#SCOPE_BOUNDARY) for all types\n * @param {string}      scope.scopeKey                  Scope key, a unique identifier tied to the scope. E.g., if your `scopeBoundary` is `GROUP`, your `scopeKey` will be your `groupKey`; for `EPISODE`, `episodeKey`, etc.\n * @param {object}      [optionals={}]                  Optional parameters\n * @param {string[]}    [optionals.filter]              List of conditionals to filter for\n * @param {string[]}    [optionals.sort]                List of values to sort by\n * @param {string[]}    [optionals.variables]           List of variables to include with the runs found\n * @param {string[]}    [optionals.metadata]            List of metadata to include with the runs found\n * @param {number}      [optionals.first]               The index from which we collect our runs from\n * @param {number}      [optionals.max]                 The maximum number of runs to return (upper limit: 200)\n * @param {number}      [optionals.timeout]             Number of seconds we're willing to wait for the response from the server\n * @param {string}      [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}      [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                    TODO\n */\nexport async function query(model, scope, optionals = {}) {\n    const { scopeBoundary, scopeKey } = scope;\n    const {\n        filter = [], sort = [], first, max, timeout, variables = [], metadata = [],\n        accountShortName, projectShortName,\n    } = optionals;\n\n    const searchParams = {\n        filter: filter.join(';') || undefined,\n        sort: sort.join(';') || undefined,\n        var: variables.join(';') || undefined,\n        meta: metadata.join(';') || undefined,\n        first, max, timeout,\n    };\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams(searchParams)\n        .get(`/run/${scopeBoundary}/${scopeKey}/${model}`, {\n            paginated: true,\n            // callback: (response) => {\n            //     response.body.values = response.body.values.map((run) => {\n            //         run.variables = variables.reduce((variableMap, key, index) => {\n            //             variableMap[key] = variables[index];\n            //             return variableMap;\n            //         }, {});\n            //         return run;\n            //     });\n            // },\n        })\n        .then(({ body }) => body);\n}\n\nexport async function introspect(model, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get(`/run/introspect/${model}`)\n        .then(({ body }) => body);\n\n}\n\nexport async function operation(runKey, name, args = [], optionals = {}) {\n    const { accountShortName, projectShortName, timeout, ritual } = optionals;\n    const hasMultiple = Array.isArray(runKey) && runKey.length > 1;\n    const uriComponent = hasMultiple ? '' : `/${runKey.length === 1 ? runKey[0] : runKey}`;\n    const searchParams = hasMultiple ? { runKey, timeout } : { ritual, timeout };\n\n    if (ritual !== RITUAL.EXORCISE && hasMultiple) {\n        console.warn(`Detected ritual: ${ritual} usage with multiple runKeys; this not allowed. Defaulting to ritual: EXORCISE`);\n    }\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams(searchParams)\n        .post(`/run/operation${uriComponent}`, {\n            body: {\n                name,\n                arguments: args,\n                objectType: 'execute', // TODO: remove this when platform fixes this so that it's not manually required\n            },\n        }).then(({ body }) => body);\n}\n\nexport async function getVariables(runKey, variables, optionals = {}) {\n    const { accountShortName, projectShortName, timeout, ritual } = optionals;\n    const include = variables.join(';');\n    const hasMultiple = Array.isArray(runKey) && runKey.length > 1;\n    const uriComponent = hasMultiple ? '' : `/${runKey.length === 1 ? runKey[0] : runKey}`;\n    const searchParams = hasMultiple ? { runKey, timeout, include } : { ritual, timeout, include };\n\n    if (ritual !== RITUAL.EXORCISE && hasMultiple) {\n        console.warn(`Detected ritual: ${ritual} usage with multiple runKeys; this not allowed. Defaulting to ritual: EXORCISE`);\n    }\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams(searchParams)\n        .get(`/run/variable${uriComponent}`)\n        .then(({ body }) => body);\n\n}\n\nexport async function getVariable(runKey, variable, optionals = {}) {\n    const { accountShortName, projectShortName, timeout, ritual } = optionals;\n\n    if (Array.isArray(runKey) || Array.isArray(variable)) {\n        const variables = Array.isArray(variable) ? variable : [variable];\n        return getVariables(runKey, variables, optionals);\n    }\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams({ timeout, ritual })\n        .get(`/run/variable/${runKey}/${variable}`)\n        .then(({ body }) => body);\n\n}\n/**\n * Updates model variables for the run\n * @memberof runAdapter\n *\n * @param {string}  runKey      Identifier for your run\n * @param {object}  update      Object with the key-value pairs you would like to update in the model\n * @param {object}  optionals   Something meaningful about optionals\n * @returns {object}            Object with the variables & new values that were updated\n */\nexport async function updateVariables(runKey, update, optionals = {}) {\n    const { accountShortName, projectShortName, timeout, ritual } = optionals;\n    const hasMultiple = Array.isArray(runKey) && runKey.length > 1;\n    const uriComponent = hasMultiple ? '' : `/${runKey.length === 1 ? runKey[0] : runKey}`;\n    const searchParams = hasMultiple ? { runKey, timeout } : { ritual, timeout };\n\n    if (ritual !== RITUAL.EXORCISE && hasMultiple) {\n        console.warn(`Detected ritual: ${ritual} usage with multiple runKeys; this not allowed. Defaulting to ritual: EXORCISE`);\n    }\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams(searchParams)\n        .patch(`/run/variable${uriComponent}`, { body: update })\n        .then(({ body }) => body);\n\n}\n\nexport async function getMetadata(runKey, variables, optionals = {}) {\n    const { accountShortName, projectShortName, timeout, ritual } = optionals;\n    const include = variables.join(';');\n    const hasMultiple = Array.isArray(runKey) && runKey.length > 1;\n    const uriComponent = hasMultiple ? '' : `/${runKey.length === 1 ? runKey[0] : runKey}`;\n    const searchParams = hasMultiple ? { runKey, timeout, include } : { ritual, timeout, include };\n\n    if (ritual !== RITUAL.EXORCISE && hasMultiple) {\n        console.warn(`Detected ritual: ${ritual} usage with multiple runKeys; this not allowed. Defaulting to ritual: EXORCISE`);\n    }\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams(searchParams)\n        .get(`/run/meta${uriComponent}`)\n        .then(({ body }) => body);\n}\n\nexport async function updateMetadata(runKey, update, optionals = {}) {\n    const { accountShortName, projectShortName, timeout, ritual } = optionals;\n    const hasMultiple = Array.isArray(runKey) && runKey.length > 1;\n    const uriComponent = hasMultiple ? '' : `/${runKey.length === 1 ? runKey[0] : runKey}`;\n    const searchParams = hasMultiple ? { runKey, timeout } : { ritual, timeout };\n\n    if (ritual !== RITUAL.EXORCISE && hasMultiple) {\n        console.warn(`Detected ritual: ${ritual} usage with multiple runKeys; this not allowed. Defaulting to ritual: EXORCISE`);\n    }\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams(searchParams)\n        .patch(`/run/meta${uriComponent}`, { body: update })\n        .then(({ body }) => body);\n\n}\n\nexport async function action(runKey, actionList, optionals = {}) {\n    const { accountShortName, projectShortName, timeout, ritual } = optionals;\n    const hasMultiple = Array.isArray(runKey) && runKey.length > 1;\n    const uriComponent = hasMultiple ? '' : `/${runKey.length === 1 ? runKey[0] : runKey}`;\n    const searchParams = hasMultiple ? { runKey, timeout } : { ritual, timeout };\n\n    if (ritual !== RITUAL.EXORCISE && hasMultiple) {\n        console.warn(`Detected ritual: ${ritual} usage with multiple runKeys; this not allowed. Defaulting to ritual: EXORCISE`);\n    }\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams(searchParams)\n        .post(`/run/action${uriComponent}`, { body: actionList })\n        .then(({ body }) => body);\n\n}\n\nasync function serial(runKey, operations, optionals = {}) {\n    const normalizedOps = operations.map((item) => ({\n        name: typeof item === 'string' ? item : item.name,\n        params: item.params,\n    }));\n\n    //Perform all operations, sequentially\n    return normalizedOps.reduce((promise, { name, params }) => {\n        return promise.then(() => operation(runKey, name, params, optionals = {}));\n    }, Promise.resolve());\n}\n\nexport async function getWithStrategy(strategy, model, scope, optionals = {}) {\n    const { initOperations = [] } = optionals;\n    if (strategy === 'reuse-across-sessions') {\n        const runs = await query(model, scope, { ...optionals, sort: ['-created'] });\n        if (runs.length) {\n            return runs[0];\n        }\n        const newRun = await create(model, scope, optionals = {});\n        await serial(newRun.runKey, initOperations, optionals = {});\n        return newRun;\n    } else if (strategy === 'reuse-never') {\n        const newRun = await create(model, scope, optionals = {});\n        await serial(newRun.runKey, initOperations, optionals = {});\n        return newRun;\n    } else if (strategy === 'reuse-by-tracking-key') {\n        //TBD write out if needed\n        //Platform plans to introduce run limits into episode scope, differing from v2's implementation of runLimit via 'reuse-by-tracking-key'\n    } else if (strategy === 'multiplayer') {\n        //TODO when multiplayer API is ready\n        //check the current world for this end user, return the current run for that world (if there is none, create a run for the world)\n    }\n    throw new EpicenterError('Invalid run strategy.');\n}\n\n\n/**\n * Returns the run associated with the given world key; if the run does not exist, it will create it.\n *\n * Base URL: POST `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/run/world/{WORLD_KEY}`\n *\n * @memberof runAdapter\n * @example\n *\n * import { runAdapter, authAdapter } from 'epicenter';\n * const worldKey = authAdapter.getLocalSession().worldKey\n * const run = await runAdapter.retrieveWithWorld('model.py', worldKey);\n *\n *\n * @param {string}  model                           Name of your model file\n * @param {object}  worldKey                        Key associated with the world you'd like a run from\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.readLock]            Role (character type)\n * @param {string}  [optionals.writeLock]           Role (chracter type)\n * @param {boolean} [optionals.ephemeral]           Used for testing. If true, the run will only exist so long as its in memory; makes it so that nothing is written to the database, history, or variables.\n * @param {string}  [optionals.trackingKey]         Tracking key\n * @param {object}  [optionals.modelContext]        .ctx2 file overrides, this is not tracked by clone operations\n * @param {object}  [optionals.executionContext]    Carries arguments for model file worker on model initialization. This is tracked by clone operations.\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                Run retrieved from the world\n */\nexport async function retrieveFromWorld(model, worldKey, optionals = {}) {\n    const {\n        readLock, writeLock, ephemeral, trackingKey,\n        modelContext, executionContext,\n        accountShortName, projectShortName,\n    } = optionals;\n    const { PARTICIPANT } = LOCK_TYPE;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .post(`/run/world/${worldKey}`, {\n            body: {\n                permit: {\n                    readLock: readLock || PARTICIPANT,\n                    writeLock: writeLock || PARTICIPANT,\n                },\n                morphology: 'MANY',\n                trackingKey,\n                modelFile: model,\n                modelContext: modelContext || {},\n                executionContext: executionContext || {},\n                ephemeral,\n            },\n        })\n        .then(({ body }) => body);\n}\n\n/**\n * Deletes the run associated with the given world key\n *\n * Base URL: DELETE `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/run/world/{WORLD_KEY}`\n *\n * @memberof runAdapter\n * @example\n *\n * import { runAdapter, authAdapter } from 'epicenter';\n * const worldKey = authAdapter.getLocalSession().worldKey\n * const run = await runAdapter.removeFromWorld(worldKey);\n *\n *\n * @param {object}  worldKey                        Key associated with the world\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                Run retrieved from the world\n */\nexport async function removeFromWorld(worldKey, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .delete(`/run/world/${worldKey}`)\n        .then(({ body }) => body);\n}","import { Router } from 'utils';\nimport { LOCK_TYPE, SCOPE_BOUNDARY } from 'utils/constants';\n\n/**\n * Episode API adapters -- use this to create, update, delete, and manage your episodes\n * @namespace vaultAdapter\n */\n\n\n/**\n * Create an episode.\n *\n * TODO -- add meaningful text here\n * @memberof vaultAdapter\n * @example\n *\n * import { vaultAdapter } from 'epicenter';\n * vaultAdapter.update\n *\n * @param {string}  vaultKey            Episode name\n * @param {object}  items               Group to make the episode under\n * @param {object}  [optionals={}]      Something meaningful about optionals\n * @returns {object}                    Something meaningful about returns\n */\nexport async function update(vaultKey, items, optionals = {}) {\n    const { accountShortName, projectShortName, mutationKey } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams({ MutationKey: mutationKey })\n        .patch(`/vault/${vaultKey}`, {\n            body: {\n                set: items.set ?? {},\n                push: items.push ?? {},\n            },\n        }).then(({ body }) => body);\n}\n\nexport async function get(vaultKey, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get(`/vault/${vaultKey}`)\n        .catch((error) => {\n            if (error.status === 404) return { body: undefined };\n            return Promise.reject(error);\n        }).then(({ body }) => body);\n}\n\nexport async function getWithScope(collection, scope, optionals = {}) {\n    const { scopeBoundary, scopeKey } = scope;\n    const { accountShortName, projectShortName } = optionals;\n    const userKey = optionals.userKey ? `/${optionals.userKey}` : '';\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get(`/vault/with/${scopeBoundary}/${scopeKey}${userKey}/${collection}`)\n        .catch((error) => {\n            if (error.status === 404) return { body: undefined };\n            return Promise.reject(error);\n        }).then(({ body }) => body);\n}\n\nexport async function remove(vaultKey, optionals = {}) {\n    const { accountShortName, projectShortName, mutationKey } = optionals;\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams({ MutationKey: mutationKey })\n        .delete(`/vault/${vaultKey}`)\n        .then(({ body }) => body);\n}\n\n\n/**\n * Creates a vault.\n *\n * Base URL: POST `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/vault/{COLLECTION_NAME}`\n *\n * @memberof runAdapter\n * @example\n *\n * import { runAdapter, SCOPE_BOUNDARY } from 'epicenter';\n * runAdapter.create('model.py', {\n *      scopeBoundary: SCOPE_BOUNDARY.GROUP,\n *      scopeKey: '000001713a246b0b34b5b5d274c057a5b2a7'\n * });\n * @param {string}  collection                      Name of the vault\n * @param {object}  scope                           Scope associated with your run\n * @param {string}  scope.scopeBoundary             Scope boundary, defines the type of scope; See [scope boundary](#SCOPE_BOUNDARY) for all types\n * @param {string}  scope.scopeKey                  Scope key, a unique identifier tied to the scope. E.g., if your `scopeBoundary` is `GROUP`, your `scopeKey` will be your `groupKey`; for `EPISODE`, `episodeKey`, etc.\n * @param {object}  items                           Defines the contents in the\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.readLock]            Role (character type)\n * @param {string}  [optionals.writeLock]           Role (chracter type)\n * @param {string}  [optionals.userKey]             Key of the user creating the run, should be `undefined` if it's a world run\n * @param {number}  [optionals.ttlSeconds]          Life span of the vault -- default to null, minimum value of 1800 (30 minutes)\n * @param {string}  [optionals.mutationKey]         Initial mutation key\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                Newly created run\n */\nexport async function create(collection, scope, items, optionals = {}) {\n    const { scopeBoundary, scopeKey } = scope;\n    const {\n        readLock, writeLock,\n        userKey, ttlSeconds, mutationKey,\n        accountShortName, projectShortName,\n    } = optionals;\n    const { WORLD } = SCOPE_BOUNDARY;\n    const { PARTICIPANT, USER } = LOCK_TYPE;\n    const defaultLock = scopeBoundary === WORLD ? PARTICIPANT : USER;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .post(`/vault/${collection}`, {\n            body: {\n                scope: {\n                    scopeBoundary,\n                    scopeKey,\n                    userKey: scopeBoundary === WORLD ? undefined : userKey,\n                },\n                permit: {\n                    readLock: readLock || defaultLock,\n                    writeLock: writeLock || defaultLock,\n                },\n                ttlSeconds,\n                mutationKey,\n                items,\n            },\n        }).then(({ body }) => body);\n\n}\n\n","import { Router, identification } from 'utils';\nimport { SCOPE_BOUNDARY } from 'utils/constants';\n\n/**\n * World API adapters -- handles worlds and user role/assignments\n * @namespace worldAdapter\n */\n\n\n/**\n * Updates fields for a particular world.\n *\n * Base URL: PATCH `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/world/{WORLD_KEY}`\n *\n * @memberof worldAdapter\n * @example\n *\n * epicenter.worldAdapter.update(world.worldKey, { name: 'World A1' });\n *\n * @param {string}  worldKey                        Key associated with world\n * @param {object}  update                          Attributes you wish to update\n * @param {string}  [update.name]                   Name of the world\n * @param {string}  [update.runKey]                 Key of the run associated with the world\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                Group with updated attributes\n */\nexport async function update(worldKey, update, optionals = {}) {\n    const { name, runKey } = update;\n    const { accountShortName, projectShortName } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .patch(`/world/${worldKey}`, {\n            body: { name, runKey },\n        })\n        .then(({ body }) => body);\n}\n\n\n/**\n * Deletes a world\n *\n * Base URL: DELETE `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/world/{WORLD_KEY}`\n *\n * @memberof worldAdapter\n * @example\n *\n * epicenter.worldAdapter.destroy(world.worldKey);\n *\n * @param {string}  worldKey                        Key associated with world\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {undefined}\n */\nexport async function destroy(worldKey, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .delete(`/world/${worldKey}`)\n        .then(({ body }) => body);\n}\n\n\n/**\n * Creates a world\n *\n * Base URL: POST `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/world/{GROUP_NAME}[/{EPISODE_NAME}]`\n *\n * @memberof worldAdapter\n * @example\n *\n * import { worldAdapter } from 'epicenter';\n * worldAdapter.create({ name: 'Whole New World' });\n *\n * @param {object}  world                           New world object\n * @param {string}  world.name                      Name of the world\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.groupName]           Name of the group (defaults to name of group associated with session)\n * @param {string}  [optionals.episodeName]         Name of the episode\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {undefined}\n */\nexport async function create(world, optionals = {}) {\n    const {\n        groupName, episodeName,\n        accountShortName, projectShortName,\n    } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .post(`/world/${groupName ?? identification.session?.groupName}${episodeName ? `/${episodeName}` : ''}`, { body: world })\n        .then(({ body }) => body);\n}\n\n\n/**\n * Fetches the worlds in a group\n *\n * Base URL: GET `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/world/{GROUP_NAME}[/{EPISODE_NAME}]`\n *\n * @memberof worldAdapter\n * @example\n *\n * import { worldAdapter } from 'epicenter';\n * const worlds = await worldAdapter.get();\n *\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.groupName]           Name of the group (defaults to name of group associated with session)\n * @param {string}  [optionals.episodeName]         Name of the episode\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object[]}                              List of worlds\n */\nexport async function get(optionals = {}) {\n    const {\n        groupName, episodeName,\n        accountShortName, projectShortName,\n    } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get(`/world/${groupName ?? identification.session?.groupName}${episodeName ? `/${episodeName}` : ''}`)\n        .then(({ body }) => body);\n}\n\n\n/**\n * Automatically assigns the current session's user to a world\n *\n * Base URL: POST `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/world/selfassign/{GROUP_NAME}[/{EPISODE_NAME}]`\n *\n * @memberof worldAdapter\n * @example\n *\n * import { worldAdapter } from 'epicenter';\n * const myWorld = await worldAdapter.selfAssign('cartographer');\n *\n * @param {string}  role                            Role to assign for, can be undefined\n * @param {object}  [optionals={}]                  Optional parameters\n * @param {string}  [optionals.groupName]           Name of the group (defaults to name of group associated with session)\n * @param {string}  [optionals.episodeName]         Name of the episode\n * @param {boolean} [optionals.exceedMinimums]      Indicates something... TODO\n * @param {string}  [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}  [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {object}                                World users were assigned to\n */\nexport async function selfAssign(role, optionals = {}) {\n    const {\n        groupName, episodeName, exceedMinimums,\n        accountShortName, projectShortName,\n    } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .post(`/world/selfassign/${groupName ?? identification.session?.groupName}${episodeName ? `/${episodeName}` : ''}`, {\n            body: { role, exceedMinimums },\n        })\n        .then(({ body }) => body);\n}\n\n\n/**\n * Assigns a list of users to a world.\n *\n * Base URL: POST `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/world/assignment/{GROUP_NAME}[/{EPISODE_NAME}]`\n *\n * @memberof worldAdapter\n * @example\n *\n * import { worldAdapter } from 'epicenter';\n * const worlds = await worldAdapter.assignUsers([\n *      { userKey: '123', role: 'locksmith' },\n *      { userKey: '456', role: 'cartographer' },\n * ]);\n *\n * @param {object[]}    assignments                         List of users to assign where each item contains a `userKey` and optional `role`\n * @param {object}      [optionals={}]                      Optional parameters\n * @param {string}      [optionals.groupName]               Name of the group (defaults to name of group associated with session)\n * @param {string}      [optionals.episodeName]             Name of the episode\n * @param {boolean}     [optionals.exceedMinimums]          Indicates something... TODO\n * @param {boolean}     [optionals.requireAllAssignments]   Indicates something... TODO\n * @param {string}      [optionals.accountShortName]        Name of account (by default will be the account associated with the session)\n * @param {string}      [optionals.projectShortName]        Name of project (by default will be the project associated with the session)\n * @returns {object[]}                                      List of worlds assigned to\n */\nexport async function assignUsers(assignments, optionals = {}) {\n    const {\n        groupName, episodeName, exceedMinimums, requireAllAssignments,\n        accountShortName, projectShortName,\n    } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .post(`/world/assignment/${groupName ?? identification.session?.groupName}${episodeName ? `/${episodeName}` : ''}`, {\n            body: { assignments, exceedMinimums, requireAllAssignments },\n        })\n        .then(({ body }) => body);\n}\n\n\n/**\n * Updates a world's user assignments. Users who have previously been assigned to a different world, will be automatically unassigned and reassigned to the provided world.\n *\n * Base URL: PUT `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/world/assignment/{WORLD_KEY}`\n *\n * @memberof worldAdapter\n * @example\n *\n * import { worldAdapter } from 'epicenter';\n * const worlds = await worldAdapter.updateUsers(world.worldKey, [\n *      { userKey: '123', role: 'locksmith' },\n *      { userKey: '456', role: 'cartographer' },\n * ]);\n *\n * @param {string}      worldKey                            Key associated with the world\n * @param {object[]}    assignments                         List of users to assign where each item contains a `userKey` and optional `role`\n * @param {object}      [optionals={}]                      Optional parameters\n * @param {boolean}     [optionals.exceedMinimums]          Indicates something... TODO\n * @param {boolean}     [optionals.requireAllAssignments]   Indicates something... TODO\n * @param {string}      [optionals.accountShortName]        Name of account (by default will be the account associated with the session)\n * @param {string}      [optionals.projectShortName]        Name of project (by default will be the project associated with the session)\n * @returns {object}                                        Updated world object\n */\nexport async function updateUsers(worldKey, assignments, optionals = {}) {\n    const {\n        exceedMinimums, requireAllAssignments,\n        accountShortName, projectShortName,\n    } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .put(`/world/assignment/${worldKey}`, {\n            body: { assignments, exceedMinimums, requireAllAssignments },\n        })\n        .then(({ body }) => body);\n}\n\n\n/**\n * Retrieves the current assignment information for a given world\n *\n * Base URL: GET `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/world/assignment/{WORLD_KEY}`\n *\n * @memberof worldAdapter\n * @example\n *\n * import { worldAdapter } from 'epicenter';\n * const assignments = await worldAdapter.getAssignments(world.worldKey);\n *\n * @param {string}      worldKey                            Key associated with the world\n * @param {object}      [optionals={}]                      Optional parameters\n * @param {string}      [optionals.accountShortName]        Name of account (by default will be the account associated with the session)\n * @param {string}      [optionals.projectShortName]        Name of project (by default will be the project associated with the session)\n * @returns {object[]}                                      List of assignment objects containing user and role information\n */\nexport async function getAssignments(worldKey, optionals = {}) {\n    const { accountShortName, projectShortName } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .get(`/world/assignment/${worldKey}`)\n        .then(({ body }) => body);\n}\n\n\n/**\n * Removes a user or list of users the all worlds in a given group or episode. Any worlds that do not contain users within them will be automatically deleted in the process.\n *\n * Base URL: DELETE `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/world/assignment?userKey={USER_KEY}[&userKey={USER_KEY}&userKey=...]`\n *\n * @memberof worldAdapter\n * @example\n *\n * import { worldAdapter } from 'epicenter';\n * await worldAdapter.removeUser(user.userKey);\n *\n * @param {string[]}    userKeys                        List of keys associated with users to remove from worlds\n * @param {object}      [optionals={}]                  Optional parameters\n * @param {string}      [optionals.groupName]           Name of the group (defaults to name of group associated with session)\n * @param {string}      [optionals.episodeName]         Name of the episode\n * @param {string}      [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}      [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {undefined}\n */\nexport async function removeUsers(userKeys, optionals = {}) {\n    const {\n        groupName, episodeName,\n        accountShortName, projectShortName,\n    } = optionals;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        .withSearchParams({ userKey: userKeys })\n        .get(`/world/assignment/${groupName ?? identification.session?.groupName}${episodeName ? `/${episodeName}` : ''}`)\n        .then(({ body }) => body);\n}\n\n\n/**\n * Edits the personas of a given scope (project, group, episode, world). Personas correspond to a role the a user in the world can be assigned to.\n *\n * Base URL: PUT `https://forio.com/api/v3/{ACCOUNT}/{PROJECT}/world/persona/{SCOPE_BOUNDARY}[/{SCOPE_KEY}]`\n *\n * @memberof worldAdapter\n * @example\n *\n * import { worldAdapter } from 'epicenter';\n * await worldAdapter.editPersonas([\n *\n * ]);\n *\n * @param {object[]}    personas                        List of persona objects containing `role`, `minimum`, and `maximum`\n * @param {object}      [scope={}]                      Scope associated with the persona set (by default the scope used will be the current project). Use this to do any specific overrides.\n * @param {string}      [scope.scopeBoundary]           Scope boundary, defines the type of scope; See [scope boundary](#SCOPE_BOUNDARY) for all types\n * @param {string}      [scope.scopeKey]                Scope key, a unique identifier tied to the scope. E.g., if your `scopeBoundary` is `GROUP`, your `scopeKey` will be your `groupKey`; for `EPISODE`, `episodeKey`, etc.\n * @param {object}      [optionals={}]                  Optional parameters\n * @param {string}      [optionals.accountShortName]    Name of account (by default will be the account associated with the session)\n * @param {string}      [optionals.projectShortName]    Name of project (by default will be the project associated with the session)\n * @returns {undefined}\n */\nexport async function editPersonas(personas, scope = {}, optionals = {}) {\n    const { scopeBoundary, scopeKey } = scope;\n    const { accountShortName, projectShortName } = optionals;\n    const boundary = scopeBoundary || SCOPE_BOUNDARY.PROJECT;\n    const uriComponent = boundary === SCOPE_BOUNDARY.PROJECT ? '' : `/${scopeKey}`;\n\n    return await new Router()\n        .withAccountShortName(accountShortName)\n        .withProjectShortName(projectShortName)\n        /* We will at some point remove the need to explicitly lower case this */\n        .put(`/world/persona/${boundary.toLowerCase()}${uriComponent}`, {\n            body: personas,\n        })\n        .then(({ body }) => body);\n}","/* Main file; defines public APIs & load order */\nconst version = VERSION;\nexport { version };\nexport {\n    SCOPE_BOUNDARY,\n    RITUAL,\n    PUSH_CATEGORY,\n    LOCK_TYPE,\n} from 'utils/constants';\nexport {\n    config,\n    errorManager,\n    Router,\n} from 'utils';\nexport {\n    Channel,\n    accountAdapter,\n    authAdapter,\n    episodeAdapter,\n    groupAdapter,\n    presenceAdapter,\n    projectAdapter,\n    runAdapter,\n    vaultAdapter,\n    worldAdapter,\n} from 'adapters';\n","import { EpicenterError, isBrowser, isNode } from 'utils';\n\nconst API_VERSION = 3;\nclass Config {\n    _apiVersion = API_VERSION;\n\n    constructor() {\n        if (isBrowser()) return this.loadBrowser();\n        if (isNode()) return this.loadNode();\n        throw new EpicenterError('Could not identify environment; no configuration was setup');\n    }\n\n    /**\n     * Protocol used to make network requests (whether `http://` or `https://`). It is typically set on-load based on your browser's URL. For local development, this is defaulted to `https`, and can be overwritten if desired.\n     * @memberof config\n     * @type {string}\n     *  */\n    get apiProtocol() {\n        return this._apiProtocol;\n    }\n\n    set apiProtocol(apiProtocol) {\n        if (!apiProtocol.startsWith('http')) return;\n        if (apiProtocol.endsWith(':')) {\n            apiProtocol = apiProtocol.slice(0, -1);\n        }\n        this._apiProtocol = apiProtocol;\n    }\n\n    /**\n     * Hostname used to make network requests. It is typically set on-load based on your browser's URL. For local development, this is defaulted to `forio.com`, and can be overwritten if desired.\n     * @memberof config\n     * @type {string}\n     *  */\n    get apiHost() {\n        return this._apiHost;\n    }\n\n    set apiHost(apiHost) {\n        this._apiHost = apiHost;\n    }\n\n    /**\n     * Version used to make network requests. This is read-only variable intended for internal use.\n     * @memberof config\n     * @type {number}\n     */\n    get apiVersion() {\n        return this._apiVersion;\n    }\n\n    set apiVersion(apiVersion) {\n        return;\n    }\n\n    /**\n     * Account name used for making network requests. This is the default value used by Epicenter API adapters when making network requests without explicitly defining an account to use. It is defined on-load based on your browser's URL, and can be overwritten for local development.\n     * @example\n     * // with browser URL: https://forio.com/app/acme-simulations/foobar-game\n     *\n     * console.log(epicenter.config.accountShortName);\n     * // should log 'acme-simulations'\n     *\n     * epicenter.runAdapter.get(123);\n     * // instantiates a GET call with the URL: https://forio.com/api/v3/acme-simulations/foobar-game/run/123\n     *\n     * epicenter.config.accountShortName = 'globex-simuations';\n     * epicenter.runAdapter.get(123);\n     * // now instantiates a GET with the URL: https://forio.com/api/v3/globex-simulations/foobar-game/run/123\n     *\n     * epicenter.runAdapter.get(123, { accountShortName: 'initech-simulations' });\n     * // now instantiates a GET with the URL: https://forio.com/api/v3/initech-simulations/foobar-game/run/123\n     *\n     * @memberof config\n     * @type {string}\n     */\n    get accountShortName() {\n        return this._accountShortName;\n    }\n\n    set accountShortName(accountShortName) {\n        this._accountShortName = accountShortName;\n    }\n    /**\n     * Project name used for making network requests. This is the default value used by Epicenter API adapters when making network requests without explicitly defining an account to use. It is defined on-load based on your browser's URL, and can be overwritten for local development.\n     * @example\n     * // with browser URL: https://forio.com/app/acme-simulations/foobar-game\n     *\n     * console.log(epicenter.config.projectShortName);\n     * // should log 'foobar-game'\n     *\n     * epicenter.runAdapter.get(123);\n     * // instantiates a GET call with the URL: https://forio.com/api/v3/acme-simulations/foobar-game/run/123\n     *\n     * epicenter.config.projectShortName = 'barfoo-game';\n     * epicenter.runAdapter.get(123);\n     * // now instantiates a GET with the URL: https://forio.com/api/v3/acme-simulations/barfoo-game/run/123\n     *\n     * epicenter.runAdapter.get(123, { projectShortName: 'barbaz-game' });\n     * // now instantiates a GET with the URL: https://forio.com/api/v3/acme-simulations/barbaz-game/run/123\n     *\n     * @memberof config\n     * @type {string}\n     */\n    get projectShortName() {\n        return this._projectShortName;\n    }\n\n    set projectShortName(projectShortName) {\n        this._projectShortName = projectShortName;\n    }\n\n    /**\n     * Use to determines whether or not the environment is local.\n     * @memberof config\n     * @return {Boolean} whether or not environment is local.\n     */\n    isLocal() {\n        if (!isBrowser()) return false;\n        const host = window.location.host;\n        return host === '127.0.0.1' ||\n            host.indexOf('local.') === 0 ||\n            host.indexOf('ngrok') !== -1 ||\n            host.indexOf('localhost') === 0;\n    }\n\n    loadNode() {\n        // TODO -- use process env variables instead here for Node server\n        this.apiProtocol = 'https';\n        this.apiHost = 'test.forio.com';\n        return;\n    }\n\n    loadBrowser() {\n        const isLocal = this.isLocal();\n        const { protocol, pathname, host } = window.location;\n        this.apiProtocol = isLocal ? 'https' : protocol;\n        this.apiHost = isLocal ? 'forio.com' : host;\n\n        const match = pathname.match(/\\/app\\/([\\w-]+)\\/([\\w-]+)/);\n        if (match) {\n            const [account, project] = match.slice(1);\n            this.accountShortName = account;\n            this.projectShortName = project;\n        }\n    }\n}\n\nconst config = new Config();\n/**\n * Configuration -- used to set up and configure global settings for Epicenter JS libs.\n * @namespace config\n */\nexport default config;\n","export const BROWSER_STORAGE_TYPE = {\n    COOKIE: 'COOKIE',\n    SESSION: 'SESSION',\n};\n\n\n/**\n * Scope boundaries are values associated with runs. They help to define the *default* user permissions used when a run is created, althought further permission configuration can be done with {@link #LOCK_TYPE lock types}. Scopes also provide an index that in which a run can be queried for.\n *\n * Three parts -- boundary: level of hierarchy (ontology) that a piece of data belongs to. Specifically, a run, an asset, or a vault data\n * Boundary in which a piece of data (run, asset, vault) is ID-ed to (see scopeKey).\n *\n * psuedonymKey, goes in tandem w/ permit (lock types) --\n * Data lives and dies with scope, delete the scope, you lose the data and associated scopes\n * @enum {string}\n */\nexport const SCOPE_BOUNDARY = {\n    /**\n     * Runs scoped by project, users and facilitators are allowed access so long as they are a user in a group on the project.\n     * @constant\n     * @type {string}\n     */\n    PROJECT: 'PROJECT',\n    /**\n     * Runs scoped by group, users and facilitators are allowed access only if they are in the associated group\n     * Groups are scoped by projects\n     * @constant\n     * @type {string}\n     */\n    GROUP: 'GROUP',\n    /**\n     * Runs scoped by episode, not sure what this one is permission-wise\n     * Episodes are scoped by groups\n     * @constant\n     * @type {string}\n     */\n    EPISODE: 'EPISODE',\n    /**\n     * Runs scoped by world, users are only allowed access to the if they are assigned to the associated world. Facilitators need only to belong on the group that created the world\n     * Worlds can be scoped by group or episode\n     * @constant\n     * @type {string}\n     */\n    WORLD: 'WORLD',\n};\n\n/**\n * Rituals are used to define the way in which the Epicenter stores a run while running actions like getting variables, saving meta data, and call model operations. Runs can exist in-memory for a certain amount of time before expiring, and requiring their revival again before use.\n * @enum {string}\n */\nexport const RITUAL = {\n    /**\n     * Allow GET action against archive, no revival of run\n     * @constant\n     * @type {string}\n     */\n    NONE: 'NONE',\n    /**\n     * A run with this ritual will be pulled into memory as needed, and will stay in memory until it's lifespan (defined in your project Settings) has expired.\n     * @constant\n     * @type {string}\n     */\n    REANIMATE: 'REANIMATE',\n    /**\n     * A run with this ritual will be pulled into memory as needed, and removed from memory afterwards.\n     * @constant\n     * @type {string}\n     */\n    EXORCISE: 'EXORCISE',\n};\n\n/**\n * Push categories are pre-defined channels types in which one might use to receive push channel updates\n * @enum {string}\n */\nexport const PUSH_CATEGORY = {\n    /**\n     * intended for messaging users\n     * yes pub\n     * @constant\n     * @type {string}\n     */\n    CHAT: 'CHAT',\n    /**\n     * Used for the {@link https://github.com/forio Consensus API}\n     * no pub\n     * @constant\n     * @type {string}\n     */\n    CONSENSUS: 'CONSENSUS',\n    /**\n     * intended for general non-chat, sim-level communication\n     * yes pub\n     * @constant\n     * @type {string}\n     */\n    CONTROL: 'CONTROL',\n    /**\n     * Used for the {@link https://github.com/forio Presence API}\n     * no pub\n     * @constant\n     * @type {string}\n     */\n    PRESENCE: 'PRESENCE',\n    /**\n     * intended for awaiting entering games\n     * yes pub\n     * @constant\n     * @type {string}\n     */\n    LOBBY: 'LOBBY',\n    /**\n     * Used for the {@link https://github.com/forio Run API}\n     * no pub\n     * @constant\n     * @type {string}\n     */\n    RUN: 'RUN',\n    /**\n     * internal\n     * @constant\n     * @type {string}\n     */\n    SYSTEM: 'SYSTEM',\n};\n\n/**\n * Lock types are used to define permissions in runs. They define which roles have which specific privileges associated with the run.\n * @enum {string}\n */\nexport const LOCK_TYPE = {\n    /**\n     * System -- Epicenter Manager\n     * @constant\n     * @type {string}\n     */\n    SYSTEM: 'SYSTEM',\n    /**\n     * System minus -- read-only system access, write for certain accounts; think Geromel\n     * @constant\n     * @type {string}\n     */\n    MONITER: 'MONITER',\n    /**\n     * Author -- Team Members (and node server API keys)\n     * tied to one account (personal + current account)\n     * @constant\n     * @type {string}\n     */\n    AUTHOR: 'AUTHOR',\n    /**\n     * Author minus\n     * @constant\n     * @type {string}\n     */\n    SUPPORT: 'SUPPORT',\n    /**\n     * Facilitators\n     * @constant\n     * @type {string}\n     */\n    FACILITATOR: 'FACILITATOR',\n    /**\n     * Reviewers (weaker facilitator)\n     * Facilitator minus\n     * @constant\n     * @type {string}\n     */\n    REVIEWER: 'REVIEWER',\n    /**\n     * Users -- psuedonymKey (userKey) required in scope\n     * e.g., an avatar -- GROUP scope, PARTICIPANT read, USER write, userKey pseudonymKey\n     * @constant\n     * @type {string}\n     */\n    USER: 'USER',\n    /**\n     * Leader\n     * Participant plus\n     * @constant\n     * @type {string}\n     */\n    LEADER: 'LEADER',\n    /**\n     * Participant\n     * @constant\n     * @type {string}\n     */\n    PARTICIPANT: 'PARTICIPANT',\n    /**\n     * Anonymous\n     * @constant\n     * @type {string}\n     */\n    ANONYMOUS: 'ANONYMOUS',\n};","// Modified version of https://github.com/madmurphy/cookies.js\nconst getExpiration = (vEnd) => {\n    if (!vEnd) return '';\n    switch (vEnd.constructor) {\n        case Number: return vEnd === Infinity ? '; expires=Fri, 31 Dec 9999 23:59:59 GMT' : `; max-age=${vEnd}`;\n        /*\n            Note: Despite officially defined in RFC 6265, the use of `max-age` is not compatible with any\n            version of Internet Explorer, Edge and some mobile browsers. Therefore passing a number to\n            the end parameter might not work as expected. A possible solution might be to convert the the\n            relative time to an absolute time. For instance, replacing the previous line with:\n        */\n        /*\n            case Number: return vEnd === Infinity ? '; expires=Fri, 31 Dec 9999 23:59:59 GMT' : `; expires=${(new Date(vEnd * 1e3 + Date.now())).toUTCString()}`;\n        */\n        case String: return `; expires=${vEnd}`;\n        case Date: return `; expires=${vEnd.toUTCString()}`;\n        default: return '';\n    }\n};\n\nexport default {\n    getItem(key) {\n        if (!key) return null;\n        return decodeURIComponent(document.cookie.replace(new RegExp(`(?:(?:^|.*;)\\\\s*${encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, '\\\\$&')}\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$`), '$1')) || null;\n    },\n    setItem(key, value, options = {}) {\n        if (!key || (/^(?:expires|max\\-age|path|domain|secure)$/i).test(key)) return false;\n\n        const { path, domain, end, secure, samesite } = options;\n        const expireStr = getExpiration(end);\n        const domainStr = domain ? `; domain=${domain}` : '';\n        const pathStr = path ? `; path=${path}` : '';\n        const secureStr = secure ? '; secure' : '';\n        const samesiteStr = samesite ? '; samesite' : '';\n\n        document.cookie = `${encodeURIComponent(key)}=${encodeURIComponent(value)}${expireStr}${domainStr}${pathStr}${secureStr}${samesiteStr}`;\n        return true;\n    },\n    removeItem(key, options = {}) {\n        if (!this.hasItem(key)) return false;\n        const { path, domain } = options;\n        const domainStr = domain ? `; domain=${domain}` : '';\n        const pathStr = path ? `; path=${path}` : '';\n        document.cookie = `${encodeURIComponent(key)}=; expires=Thu, 01 Jan 1970 00:00:00 GMT${domainStr}${pathStr}`;\n        return true;\n    },\n    hasItem(key) {\n        if (!key || (/^(?:expires|max\\-age|path|domain|secure)$/i).test(key)) return false;\n\n        return (new RegExp(`(?:^|;\\\\s*)${encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, '\\\\$&')}\\\\s*\\\\=`)).test(document.cookie);\n    },\n    clear() {\n        const aKeys = document.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, '').split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        for (let nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) {\n            aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]);\n            this.removeItem(aKeys[nIdx]);\n        }\n        return aKeys;\n    },\n};\n","import { authAdapter } from 'adapters';\nimport { identification, isNode } from 'utils';\n\n\nconst handleByRelog = (error) => {\n    let query = '';\n    if (error.code) {\n        query = query.concat(`?error=${error.code}`);\n    }\n    return authAdapter.logout().then(() => window.location.href = `/login.html${query}`);\n};\n\nconst handleSSO = () => {\n    return authAdapter.logout();\n};\n\nconst handleUnknown = () => {\n    return authAdapter.logout().then(() => window.location.href = '/unknown.html');\n};\n\nconst handleByLoginMethod = (error) => {\n    const { session } = identification;\n    const loginType = session?.loginMethod?.objectType;\n    switch (loginType) {\n        case 'sso': return handleSSO(error);\n        case 'none':return handleUnknown(error);\n        case 'native':\n        default: return handleByRelog(error);\n    }\n};\n\nconst UNAUTHORIZED = 401;\nclass ErrorManager {\n    _handlers = [\n        {/* Default Unauthorized (401) Error Handler */\n            identifier: (error) => error.status === UNAUTHORIZED,\n            handle: (error, retry) => {\n                if (error.code === 'AUTHENTICATION_INVALIDATED') {\n                    const groupKey = identification.session.groupKey;\n                    return authAdapter.upgrade(groupKey, { objectType: 'user', inert: true })\n                        .then(() => retry())\n                        .catch(() => handleByLoginMethod(error));\n                }\n                if (isNode()) return Promise.reject(error);\n                return handleByLoginMethod(error);\n            },\n        },\n    ];\n\n    get handlers() {\n        return this._handlers;\n    }\n\n    registerHandler(identifier, handleFn) {\n        this.handlers.unshift({\n            identifier,\n            handle: handleFn,\n        });\n    }\n\n    async handle(error, retryFn, handlers/* which is undefined unless recursing */) {\n        handlers = handlers || this.handlers;\n        const index = handlers.findIndex(({ identifier }) => identifier(error));\n        const handler = handlers[index];\n        const remainingHandlers = index > 0 ? handlers.slice(index + 1) : [];\n        if (!handler) throw error;\n        let promise;\n        try {\n            promise = await handler.handle(error, retryFn).catch((err) => {\n                /* This catch call ensures that handle always returns a promise,\n                otherwise it'd be caught in the catch block below */\n                throw err;\n            });\n        } catch (e) {\n            promise = await this.handle(error, retryFn, remainingHandlers);\n        }\n        return promise;\n    }\n}\n\nconst errorManager = new ErrorManager();\n/**\n * Configuration -- used to set up and configure global settings for Epicenter JS libs.\n * @namespace errorManager\n */\nexport default errorManager;\n","\n/* Generic throwable error */\nexport default class EpicenterError extends Error {\n\n    constructor(message) {\n\n        super(message);\n\n    }\n}","\n/* For failed network calls */\nexport default class Fault extends Error {\n\n    constructor(body, response) {\n\n        super();\n        const { status } = response;\n        const { information, message, cause } = body;\n        this.status = status;\n        this.message = message;\n\n        if (information) {\n            const { code, ...rest } = information;\n            this.code = code;\n            this.information = rest;\n        }\n        if (cause) {\n            this.cause = new Fault(cause);\n        }\n    }\n}","/* eslint-disable no-new-func */\nexport const isBrowser = new Function('try {return this===window;}catch(e){ return false;}');\nexport const isNode = new Function('try {return this===global;}catch(e){return false;}');\n\n\nexport const last = (strOrArr) => strOrArr[strOrArr.length - 1];\nexport const prefix = (pre, str) => str.startsWith(pre) ? str : `${pre}${str}`;\n\n// Tries to return value at the end of a sequence of keys.\n// E.g. given an obj and keys = ['1', '2', '3'], it will try to\n// return obj['1']['2']['3']. Uses the defaultValue on error.\nexport const access = (obj, keys, defaultValue) => {\n    let ref = obj;\n    try {\n        keys.forEach((key) => ref = ref[key]);\n    } catch (err) {\n        if (err instanceof TypeError) {\n            return defaultValue;\n        }\n        throw err;\n    }\n    if (ref === undefined) return defaultValue;\n    return ref;\n};","import { EpicenterError, NodeStore, SessionStore, CookieStore, cookies, isNode, config } from 'utils';\nimport { BROWSER_STORAGE_TYPE } from 'utils/constants';\nconst { COOKIE, SESSION } = BROWSER_STORAGE_TYPE;\n\n\nconst SESSION_KEY = Symbol('com.forio.epicenter.session');\nconst EPI_SSO_KEY = 'epicenter.v3.sso';\nclass Identification {\n    type\n\n    constructor(storeType) {\n        if (storeType !== COOKIE && storeType !== SESSION) {\n            throw new EpicenterError(`Invalid Storage Type: \"${storeType}\", please use \"${COOKIE}\" or \"${SESSION}\".`);\n        }\n        this.type = storeType;\n        this.consumeSSO();\n    }\n    get session() {\n        const Store = this.getStore();\n        return new Store().getItem(SESSION_KEY.description);\n    }\n    set session(session) {\n        const Store = this.getStore();\n        const path = this.getSessionPath(session);\n\n        if (session) {\n            new Store({ path }).setItem(SESSION_KEY.description, session);\n        } else if (this.session) {\n            new Store({ path }).removeItem(SESSION_KEY.description);\n        }\n    }\n    getStore() {\n        if (isNode()) return NodeStore;\n        switch (this.type) {\n            case SESSION: return SessionStore;\n            case COOKIE:\n            default: return CookieStore;\n        }\n    }\n    /* Generates the appropriate path for storing your session (applicable only to cookies) */\n    getSessionPath(session) {\n        const mySession = session || this.session;\n        if (!mySession || isNode()) return '';\n\n        const { accountShortName, projectShortName, objectType } = mySession;\n        const isLocal = config.isLocal();\n        const isCustomDomain = !isLocal && window.location.pathname.split('/')[1] !== 'app';\n        const isEpicenterDomain = !isLocal && !isCustomDomain;\n        if (objectType === 'user' && accountShortName && projectShortName && isEpicenterDomain) {\n            return `/app/${accountShortName}/${projectShortName}`;\n        }\n        /* Admins and any custom domains (ones that don't use 'app/account/project') get the root path */\n        return '/';\n    }\n    consumeSSO() {\n        if (isNode()) return;\n        /* Double parse here b/c the backend serializes it as a string; the first parse\n         * converts it into a json string, the second parse converts the json string into\n         * json. Yes, it's weird, no, we can't change it (unless we want to rewrite\n         * Interface Builder code to accommodate) */\n        const session = JSON.parse(JSON.parse(`\"${cookies.getItem(EPI_SSO_KEY)}\"`));\n        if (session) {\n            const { accountShortName, projectShortName } = session;\n            this.session = session;\n            cookies.removeItem(EPI_SSO_KEY, { domain: `.${window.location.hostname}`, path: `/app/${accountShortName}/${projectShortName}` });\n        }\n    }\n}\n\nconst identification = new Identification(COOKIE);\nexport default identification;\n\n","export * from './constants';\nexport * from './helpers';\nexport * from './store';\nexport { default as cookies } from './cookies';\nexport { default as EpicenterError } from './error';\nexport { default as Fault } from './fault';\nexport { default as Result } from './result';\nexport { default as config } from './config';\nexport { default as identification } from './identification';\nexport { default as errorManager } from './error-manager';\nexport { default as Router } from './router';\n","\n/* For network call responses */\nexport default class Result {\n\n    constructor(body, response) {\n        const { status, headers } = response;\n        this.status = status;\n        this.headers = headers;\n        this.body = body;\n\n    }\n}","import fetch from 'cross-fetch';\nimport { EpicenterError, Fault, Result, identification, prefix, errorManager, config } from 'utils';\n\n\nconst DEFAULT_ACCOUNT_SHORT_NAME = 'epicenter';\nconst DEFAULT_PROJECT_SHORT_NAME = 'manager';\nconst MAX_URL_LENGTH = 2048;\n\nfunction paginate(json, url, options) {\n    const page = { ...json, allValues: [...json.values] };\n\n    const next = async function() {\n        const searchParams = new URLSearchParams(url.search);\n        const first = page.firstResult + page.maxResults;\n        if (page.allValues.length >= json.totalResults) {\n            page.done = true;\n            return page;\n        }\n\n        searchParams.set('first', first);\n        url.search = searchParams;\n        // eslint-disable-next-line no-use-before-define\n        const nextPage = await request(url, { ...options, paginated: false }).then(({ body }) => body);\n        page.allValues = page.allValues.concat(nextPage.values);\n        Object.assign(page, nextPage);\n        return page;\n    };\n\n    const withAll = async function() {\n        // eslint-disable-next-line callback-return\n        const { done, allValues } = await next();\n        if (done) return allValues;\n        return await withAll();\n    };\n\n    page.next = next;\n    page.withAll = withAll;\n    return page;\n}\n\nconst createHeaders = (includeAuthorization) => {\n    const headers = {\n        'Content-type': 'application/json; charset=UTF-8',\n    };\n    const { session } = identification;\n    if (includeAuthorization && session) {\n        headers.Authorization = `Bearer ${session.token}`;\n    }\n    if (includeAuthorization && config.tokenOverride) {\n        headers.Authorization = `Bearer ${config.tokenOverride}`;\n    }\n    return headers;\n};\n\nasync function request(url, options) {\n    const { method, body, includeAuthorization, inert, paginated } = options;\n    const headers = createHeaders(includeAuthorization);\n    const response = await fetch(url, {\n        method: method,\n        cache: 'no-cache',\n        headers: headers,\n        redirect: 'follow',\n        body: body ? JSON.stringify(body) : null,\n    });\n\n    const contentType = response.headers.get('content-type');\n    if (!contentType || !contentType.includes('application/json')) {\n        throw new EpicenterError(`Response content-type '${contentType}' does not include 'application/json'`);\n    }\n\n    const json = await response.json();\n    if ((response.status >= 200) && (response.status < 400)) {\n        return new Result(\n            paginated ? paginate(json, url, options) : json,\n            response\n        );\n    }\n\n    const error = new Fault(json, response);\n    if (inert) throw error;\n\n    const retry = () => request(url, { method, body, includeAuthorization, inert: true });\n    return errorManager.handle(error, retry);\n}\n\n/**\n * Used to make the network calls in all API adapters\n */\nexport default class Router {\n    /**\n     * The root path used for the call, essentially protocol + hostname\n     * @type {string}\n     */\n    get server() {\n        return this._server;\n    }\n    set server(value) {\n        this._server = value;\n    }\n\n    /**\n     * The version of the Epicenter APIs being invoked; expected to stay at `3`\n     * @type {number}\n     */\n    get version() {\n        return this._version;\n    }\n    set version(value) {\n        this._version = value;\n    }\n\n    /**\n     * Name of the account; for administrative use, this value should be set to 'epicenter'\n     * @type {string}\n     */\n    get accountShortName() {\n        return this._accountShortName;\n    }\n    set accountShortName(value) {\n        this._accountShortName = value;\n    }\n\n    /**\n     * Name of the project; for administrative use, this value should be set to 'manager'\n     * @type {string}\n     */\n    get projectShortName() {\n        return this._projectShortName;\n    }\n    set projectShortName(value) {\n        this._projectShortName = value;\n    }\n\n    /**\n     * The search parameters for to use when making a network request. This property has should always return an instance of URLSearchParams or undefined. It has unique properties when used with the assignment operator (`=`); see the examples below for more details.\n     * @type {URLSearchParams}\n     *\n     * @example\n     * const router = new Router();\n     * router.searchParams = '?foo=123';\n     * console.log(router.searchParams);                            // always returns an instance object: URLSearchParams {}\n     * console.log(router.searchParams.toString());                 // logs 'foo=123'\n     *\n     * router.searchParams = 'foo=123';                             // can omit the question mark\n     * console.log(router.searchParams.toString());                 // logs 'foo=123'\n     *\n     * router.searchParams = [['foo', '123'], ['bar', '456']];      // can accept arrays\n     * console.log(router.searchParams.toString());                 // logs 'foo=123&bar=456'\n     *\n     * router.searchParams = { foo: '123', bar: '456' };            // can accept objects\n     * console.log(router.searchParams.toString());                 // logs 'foo=123&bar=456'\n     *\n     * router.searchParams = { foo: '123', bar: ['4', '5', '6'] };  // can accept objects with arrayed values\n     * console.log(router.searchParams.toString());                 // logs 'foo=123&bar=4&bar=5&bar=6'\n     *\n     * router.searchParams = new URLSearchParams('foo=123');        // can accept instances of URLSearchParams\n     * console.log(router.searchParams.toString());                 // logs 'foo=123'\n     *\n     * @param {object|array|string|URLSearchParams} query   Value used to set the search parameters\n     */\n    get searchParams() {\n        return this._searchParams;\n    }\n    set searchParams(query) {\n        if (query.constructor === URLSearchParams) {\n\n            this._searchParams = query;\n            return;\n        }\n\n        /* 'query' should be either an array, or string. Objects will be coerced into [key, value] arrays */\n        if (typeof query === 'object' && query.constructor === Object) {\n            query = Object.entries(query).reduce((arr, [key, value]) => {\n                if (Array.isArray(value)) {\n                    /* Special case for arrayed param values: use duplicated params here */\n                    return [...arr, ...value.map((v) => [key, v])];\n                }\n                if (value === undefined || value === null) {\n                    /* Skip nullish values */\n                    return arr;\n                }\n                arr.push([key, value]);\n                return arr;\n            }, []);\n        }\n        this._searchParams = new URLSearchParams(query);\n    }\n\n    /**\n     * Sets the root path. Does nothing if invoked with no input. This is a part of a series of convenience functions for chaining sets on values.\n     * @param {string} [server] Root path to use\n     * @returns {Router}        The Router instance\n     */\n    withServer(server) {\n        if (typeof server !== 'undefined') this.server = server;\n        return this;\n    }\n\n    /**\n     * Sets the version. Does nothing if invoked with no input. This is a part of a series of convenience functions for chaining sets on values.\n     * @param {string} [version]    Version to use\n     * @returns {Router}            The Router instance\n     */\n    withVersion(version) {\n        if (typeof version !== 'undefined') this.version = version;\n        return this;\n    }\n\n    /**\n     * Sets the account. Does nothing if invoked with no input. This is a part of a series of convenience functions for chaining sets on values.\n     * @param {string} [accountShortName]   Account name to use\n     * @returns {Router}                    The Router instance\n     */\n    withAccountShortName(accountShortName) {\n        if (typeof accountShortName !== 'undefined') this.accountShortName = accountShortName;\n        return this;\n    }\n\n    /**\n     * Sets the project. Does nothing if invoked with no input. This is a part of a series of convenience functions for chaining sets on values.\n     * @param {string} [projectShortName]   Project name to use\n     * @returns {Router}                    The Router instance\n     */\n    withProjectShortName(projectShortName) {\n        if (typeof projectShortName !== 'undefined') this.projectShortName = projectShortName;\n        return this;\n    }\n\n    /**\n     * Sets the search parameters. Does nothing if invoked with no input. This is a part of a series of convenience functions for chaining sets on values.\n     * @param {string|array|object|URLSearchParams} [searchParams]  Search parameters to use, utilizes the same setter as [searchParams](#Router-searchParams)\n     * @returns {Router}                                            The Router instance\n     */\n    withSearchParams(searchParams) {\n        if (typeof searchParams !== 'undefined') this.searchParams = searchParams;\n        return this;\n    }\n\n    getURL(uriComponent) {\n        if (!this.server) this.withServer(`${config.apiProtocol}://${config.apiHost}`);\n        if (!this.accountShortName) this.withAccountShortName(config.accountShortName);\n        if (!this.projectShortName) this.withProjectShortName(config.projectShortName);\n        if (!this.version) this.withVersion(config.apiVersion);\n\n        const url = new URL(`${this.server}`);\n        url.pathname = `api/v${this.version}/${this.accountShortName}/${this.projectShortName}${prefix('/', uriComponent)}`;\n        url.search = this.searchParams ?? new URLSearchParams();\n        return url;\n    }\n\n    //Network Requests\n    async get(uriComponent, options) {\n        const url = this.getURL(uriComponent);\n\n        /* Handle sufficiently large GET requests with POST calls instead */\n        if (url.href.length > MAX_URL_LENGTH) {\n            const newURL = new URL(url.href.split('?')[0]);\n            return this.post(newURL, {\n                ...options,\n                body: url.search,\n            });\n        }\n\n        return request(url, {\n            includeAuthorization: true,\n            ...options,\n            method: 'GET',\n        });\n    }\n\n    async delete(uriComponent, options) {\n        const url = this.getURL(uriComponent);\n        return request(url, {\n            includeAuthorization: true,\n            ...options,\n            method: 'DELETE',\n        });\n    }\n\n    async patch(uriComponent, options) {\n        const url = this.getURL(uriComponent);\n        return request(url, {\n            includeAuthorization: true,\n            ...options,\n            method: 'PATCH',\n        });\n    }\n\n    async post(uriComponent, options) {\n        const url = this.getURL(uriComponent);\n        return request(url, {\n            includeAuthorization: true,\n            ...options,\n            method: 'POST',\n        });\n    }\n\n    async put(uriComponent, options) {\n        const url = this.getURL(uriComponent);\n        return request(url, {\n            includeAuthorization: true,\n            ...options,\n            method: 'PUT',\n        });\n    }\n}\n","import { cookies } from 'utils';\n\nclass Store {\n    _store;\n    constructor(store) {\n        this._store = store;\n    }\n    clear() {\n        this._store.clear();\n    }\n    get store() {\n        return this._store;\n    }\n    set store(store) {\n        this._store = store;\n    }\n}\n\nconst nodeMap = new Map();\nexport class NodeStore extends Store {\n    constructor() {\n        super(nodeMap);\n    }\n    getItem(key) {\n        return super.store.get(key);\n    }\n    setItem(key, value) {\n        return super.store.set(key, value);\n    }\n    removeItem(key) {\n        return super.store.delete(key);\n    }\n}\n\nexport class SessionStore extends Store {\n    constructor() {\n        super(window.sessionStorage);\n    }\n    getItem(key) {\n        return JSON.parse(super.store.getItem(key.toString()));\n    }\n    setItem(key, value) {\n        return super.store.setItem(key.toString(), JSON.stringify(value));\n    }\n    removeItem(key) {\n        return super.store.removeItem(key.toString());\n    }\n}\n\nexport class CookieStore {\n    constructor(options) {\n        const defaults = { domain: `.${window.location.hostname}`, path: '/' };\n        this.options = { ...defaults, ...options };\n    }\n    getItem(key) {\n        return JSON.parse(cookies.getItem(key.toString()));\n    }\n    setItem(key, value) {\n        return cookies.setItem(key.toString(), JSON.stringify(value), this.options);\n    }\n    removeItem(key) {\n        return cookies.removeItem(key.toString(), this.options);\n    }\n    clear() {\n        return cookies.clear();\n    }\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1CA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACz1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACxtBA;AAEA;;;;;AAKA;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AACA;AANA;AAEA;AAFA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAUA;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AACA;AANA;AAEA;AAFA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AASA;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;AALA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AAGA;;;;;AAMA;;;;;;;;;;;AAUA;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AACA;;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AACA;AAFA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAHA;AAIA;AAAA;AAAA;AACA;AAXA;AAGA;AAHA;AAAA;AACA;AADA;AAaA;AAbA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAiBA;AAAA;AAAA;AACA;;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAEA;AAFA;AAAA;AAQA;AAAA;AAAA;AAAA;AACA;AAFA;AAGA;AAAA;AAAA;AACA;AAXA;AAIA;AAJA;AAAA;AACA;AADA;AAaA;AAbA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAiBA;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAOA;AAAA;AAAA;AACA;AARA;AAGA;AAMA;AATA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAaA;AAAA;AAAA;AACA;;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AAEA;AAHA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAOA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AAMA;;;;AAIA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;;AAIA;AACA;AACA;;;;AAEA;;;;;;;AACA;;;;;;AAAA;AACA;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAGA;;;;;;AACA;AACA;;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;;;;;AACA;AAAA;AACA;AADA;AACA;AACA;AAFA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AARA;AASA;AACA;;AAXA;AACA;AAYA;;;;;;;;;;;;AAMA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;;AACA;AACA;;AADA;AACA;AAAA;;;;;AAAA;AACA;;AAAA;;;;;;AACA;AACA;;AADA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AAEA;;;;;;AACA;AACA;;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AAEA;;;;;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;;;AAEA;AACA;;;;;;;;;;;;;;;;;AAAA;;AACA;AACA;;AACA;;;;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AApBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;;;;AAAA;AACA;;;AACA;AACA;;;AAAA;AACA;;AAAA;;;;;AAAA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AACA;;;;;;;;;;;;;;;;;;AAQA;;;;;;;;;;;;;;AAAA;;AACA;AACA;;AAAA;AACA;AACA;;;;;;AACA;AACA;;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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","sourceRoot":""}